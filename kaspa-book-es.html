<!DOCTYPE html>
<html lang="es">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="content-type">
<title>Kaspa: El Protocolo de Próxima Generación</title>
<style type="text/css">
  body {
    font-family: 'Arial', sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f8f9fa;
    margin: 0;
    padding: 0;
  }
  .container {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
    background-color: #ffffff;
    border: 1px solid #dee2e6;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
  }
  h1, h2, h3, h4 {
    color: #2c3e50;
    line-height: 1.3;
    page-break-after: avoid;
  }
  h1.book-title {
    font-size: 2.5em;
    text-align: center;
    margin-bottom: 0.5em;
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
  }
  h2.chapter-title {
    font-size: 2em;
    margin-top: 1.5em;
    border-bottom: 1px solid #bdc3c7;
    padding-bottom: 5px;
  }
  h3.section-title {
    font-size: 1.5em;
    margin-top: 1.2em;
    color: #34495e;
  }
  h4.subsection-title {
    font-size: 1.2em;
    margin-top: 1em;
    color: #7f8c8d;
  }
  p {
    text-align: justify;
    margin-bottom: 1em;
  }
  .img-container {
    display: block;
    width: 100%;
    max-width: 600px;
    height: auto;
    margin: 20px auto;
    text-align: center;
    box-sizing: border-box;
  }
  .img-container img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0 auto;
  }
  .author-date {
    text-align: right;
    font-style: italic;
    color: #7f8c8d;
    margin-bottom: 2em;
  }
  .simplified-def {
    background-color: #ecf0f1;
    border-left: 5px solid #3498db;
    padding: 15px;
    margin: 1.5em 0;
  }
  .simplified-def b {
    color: #2980b9;
  }
  ul {
    list-style-type: disc;
    margin-left: 20px;
    padding-left: 20px;
  }
  li {
    margin-bottom: 0.5em;
  }
  blockquote {
    border-left: 4px solid #bdc3c7;
    padding-left: 15px;
    margin-left: 0;
    font-style: italic;
    color: #7f8c8d;
  }
  hr.chapter-break {
    page-break-before: always;
    border: 0;
  }
  .cover-page {
    text-align: center;
    padding: 100px 20px;
    border: 2px solid #2c3e50;
    margin-bottom: 50px;
  }
  .cover-page .title {
    font-size: 3em;
    color: #2c3e50;
  }
  .cover-page .subtitle {
    font-size: 1.5em;
    color: #7f8c8d;
  }
  .cover-page .author {
    margin-top: 50px;
    font-size: 1.2em;
  }
  .conclusion, .introduction {
      padding: 20px;
      background-color: #eaf2f8;
      border-radius: 5px;
  }
/* Styles pour la Table des Matières */
.table-of-contents {
  background-color: #f0f8ff; /* Light blue background */
  border: 1px solid #cceeff; /* Light blue border */
  padding: 20px;
  margin: 20px auto;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.table-of-contents .chapter-title {
  text-align: center;
  margin-bottom: 20px;
  color: #2c3e50;
  border-bottom: 1px solid #aaddff;
  padding-bottom: 10px;
}

.table-of-contents ul {
  list-style: none; /* Remove default bullet points */
  padding-left: 0;
}

.table-of-contents ul ul {
  padding-left: 20px; /* Indent for subsections */
  margin-top: 5px;
}

.table-of-contents li {
  margin-bottom: 8px;
}

.table-of-contents li a {
  text-decoration: none;
  color: #3498db; /* Blue link color */
  font-weight: bold;
  transition: color 0.2s ease;
}

.table-of-contents li a:hover {
  color: #2980b9; /* Darker blue on hover */
}

.table-of-contents ul ul li a {
  font-weight: normal; /* Normal font for subsections */
  font-size: 0.95em;
  color: #555; /* Slightly darker color for subsections */
}

.table-of-contents ul ul li a:hover {
  color: #333;
}

.table-of-contents .no-id-link {
    color: #7f8c8d; /* Grey out unlinked items */
    font-style: italic;
}
</style>
</head>
<body>
<div class="container">

  <div class="cover-page">
    <h1 class="title">Kaspa: El Protocolo de Próxima Generación</h1>
    <p class="subtitle">Una Guía Completa de BlockDAG, Consenso y el Futuro de la Moneda Digital</p>
    <p class="author">Compilado y enriquecido por la Comunidad (27 de julio de 2025)</p>
  </div>

  <hr class="chapter-break">

  <div class="introduction">
    <h2 class="chapter-title">Introducción</h2>
    <p>Bienvenido a esta guía completa dedicada a Kaspa, una criptomoneda que no solo itera sobre tecnologías existentes, sino que las reinventa fundamentalmente. En un ecosistema donde miles de proyectos compiten por la atención, Kaspa se distingue por un enfoque riguroso y profundas innovaciones que buscan resolver los problemas más fundamentales de las blockchains tradicionales: escalabilidad, velocidad y descentralización, sin compromiso.</p>
    <p>Este libro tiene como objetivo desmitificar los conceptos complejos que subyacen a Kaspa. Comenzaremos con los conceptos básicos, explicando qué es un Grafo Dirigido Acíclico (DAG) y cómo el protocolo GHOSTDAG de Kaspa lo utiliza para crear un sistema de consenso que es rápido, seguro y totalmente descentralizado. Ya sea usted un desarrollador curioso, un inversor que busca comprender la tecnología subyacente o simplemente un entusiasta de las criptomonedas, este libro está diseñado para guiarle paso a paso.</p>
    <p>Exploraremos cómo Kaspa ha resuelto el "trilema de la blockchain", cómo su arquitectura única permite confirmaciones casi instantáneas y cómo gestiona el almacenamiento de datos de forma sostenible a través de un sofisticado sistema de poda. También cubriremos temas más avanzados como su resistencia al MEV (Valor Extraíble Máximo), su visión para soluciones de Capa 2 con ZK-Rollups y la dinámica económica de su mercado de tarifas.</p>
    <p>Este trabajo es el resultado de un esfuerzo colectivo. Quiero expresar mi profunda gratitud a los colaboradores de la comunidad Kaspa, cuyos artículos, investigaciones y discusiones han formado la columna vertebral de este libro. Gran parte del contenido ha sido adaptado y traducido de los invaluables recursos disponibles en el sitio web oficial <strong><a href="https://kaspa.com/learn-kaspa">Kaspa.com/learn-kaspa</a></strong> y los escritos de sus principales investigadores y desarrolladores. También se extiende un agradecimiento especial a <strong>Cihan0x.ETH (<a href="https://x.com/cihan0xeth/status/1949361083883380833">@cihan0xeth</a>)</strong>, cuyo trabajo se basa en parte en los análisis originales de <strong>@AbiKaspa</strong>, y a <strong>BankQuote_DAG</strong> por sus perspicaces análisis que han enriquecido enormemente este trabajo.</p>
    <p>Prepárese para sumergirse en una de las arquitecturas más innovadoras del mundo de las criptomonedas. Prepárese para entender Kaspa.</p>
  </div>

  <hr class="chapter-break">

<div class="table-of-contents">
      <h2 class="chapter-title">Tabla de Contenidos</h2>
      <ul>
          <li><a href="#h.sbugt7p65zq6">Capítulo 1: BlockDAG de Kaspa</a>
              <ul>
                  <li><a href="#h.52y7zpxatzmc">DAG - Grafo Dirigido Acíclico</a></li>
                  <li><a href="#h.r0onrjvzaye8">Bitcoin y Kaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.q9lxzgpefpuh">Capítulo 2: Kaspa - Vinculando el Cuerpo al Encabezado</a>
              <ul>
                  <li><a href="#h.3ezesbjpkjql">Asegurando el Cuerpo del Bloque al Encabezado - Raíz Merkle</a></li>
                  <li><a href="#h.emrhhaf2640n">Bitcoin y Kaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.y0ik307h70q9">Capítulo 3: Kaspa y el "Problema de Escalabilidad de Bitcoin"</a>
              <ul>
                  <li><a href="#h.2jy3kmwufuue">Kaspa resolvió el "Problema de Escalabilidad de Bitcoin" - ¿Qué es?</a></li>
                  <li><a href="#h.v4bl36mx6e0u">Bitcoin y Kaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.1tq8u5wwr5up">Capítulo 4: MuHash</a>
              <ul>
                  <li><a href="#h.ny65anmiz0s">¿Qué es MuHash y cómo lo usa Kaspa?</a></li>
                  <li><a href="#h.focbph7aurgq">Bitcoin y Kaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.oy0kgniero14">Capítulo 5: Modelo UTXO de Kaspa</a>
              <ul>
                  <li><a href="#h.8nqvw067oam1">¿Qué es un UTXO y cómo lo usa Kaspa?</a></li>
                  <li><a href="#h.5v09d76siagw">Bitcoin y Kaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.6x07cz5zmxim">Capítulo 6: Padres vs. Mergeset</a>
              <ul>
                  <li><a href="#h.34xcaoqpznos">¿Qué son Padres y Mergeset y cómo los usa Kaspa?</a></li>
                  <li><a href="#h.tsab66lazd4a">Bitcoin vs. Kaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.x0nj4tecoh66">Capítulo 7: Poda de Segundo Orden</a>
              <ul>
                  <li><a href="#h.1wbq42gt63wc">¿Qué es la poda de segundo orden y cómo la usa Kaspa?</a></li>
              </ul>
          </li>
          <li><a href="#h.mz2dlkhrvwd2">Capítulo 8: GHOSTDAG de Kaspa Simplificado</a>
              <ul>
                  <li><a href="#h.hwkbrs8egi6p">¿Qué es GHOSTDAG y cómo lo usa Kaspa?</a></li>
              </ul>
          </li>
          <li><a href="#h.drxg3f8wwuwc">Capítulo 9: Terminología DAG</a>
              <!-- Note: Some subsections in Chapter 9 do not have IDs in the original HTML and thus cannot be linked directly. -->
          </li>
          <li><a href="#h.1uals18cttyl">Capítulo 10: Poda de Primer Orden</a>
              <ul>
                  <li><a href="#h.3i8fyh1jrh8m">¿Qué es la poda de primer orden y cómo la usa Kaspa?</a></li>
              </ul>
          </li>
          <li><a href="#h.juf0jn9hl1ev">Capítulo 11: Nodos de Archivo vs. Nodos Completos</a>
              <ul>
                  <li><a href="#h.knim47a94vo6">Nodos de Archivo de Kaspa vs. Nodos de Poda</a></li>
              </ul>
          </li>
          <li><a href="#h.xoj5wjv6tg4b">Capítulo 12: Kaspa: Una Evolución en la Arquitectura Descentralizada Eficiente en Energía</a>
              <ul>
                  <li><a href="#h.pfav0qmvzt92">Introducción: La Física del Dinero y la Eficiencia</a></li>
                  <!-- Note: Some subsections in Chapter 12 do not have IDs in the original HTML and thus cannot be linked directly. -->
                  <li><a href="#h.y2juit6511i3">BlockDAG de Kaspa: Paralelismo sin Trabajo Desperdiciado</a></li>
                  <li><a href="#h.ttddfh4xlbpu">Logrando un Rendimiento a la Velocidad de la Luz</a></li>
                  <li><a href="#h.uttpgy92hgk">Menos Fricción, Mejor Retención de Valor</a></li>
              </ul>
          </li>
          <li><a href="#h.e01avawvoirc">Capítulo 13: Kaspa vs. Ordenamiento de Bitcoin</a>
              <!-- Note: Some subsections in Chapter 13 do not have IDs in the original HTML and thus cannot be linked directly. -->
          </li>
          <li><a href="#chapter14">Capítulo 14: Visión de Kaspa para la Capa 2: ZK Rollups y Bridging</a></li>
          <li><a href="#chapter15">Capítulo 15: La Red Igra: Un Caso de Estudio del ZK Rollup Compatible con EVM de Kaspa</a></li>
          <li><a href="#chapter16">Capítulo 16: Rendimiento de Transacciones y Colisiones en el BlockDAG de Kaspa</a></li>
          <li><a href="#chapter17">Capítulo 17: Mercado de Tarifas de Kaspa: Una Perspectiva de la Teoría de Juegos</a></li>
          <li><a href="#conclusion">Conclusión</a></li>
          <li><a href="#appendixA">Apéndice A: Recursos Adicionales</a></li>
          <li><a href="#appendixB">Apéndice B: Análisis Matemático de Colisiones de Transacciones (Simplificado)</a></li>
          <li><a href="#appendixC">Apéndice C: Análisis Matemático del Mercado de Tarifas (Simplificado)</a></li>
      </ul>
  </div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.sbugt7p65zq6">Capítulo 1: BlockDAG de Kaspa</h2>
  <div class="img-container"><img alt="BlockDAG de Kaspa" src="images/image1.png"></div>
  <h3 class="section-title" id="h.52y7zpxatzmc">DAG - Grafo Dirigido Acíclico</h3>
  <p>Probablemente haya oído que Kaspa es un BlockDAG, pero ¿qué significa eso? Este artículo está diseñado para no asumir conocimientos previos, por lo que comenzaremos con la teoría de grafos. Primero veremos qué es un Grafo, luego qué es un Grafo Dirigido, luego llegaremos al Grafo Dirigido Acíclico y finalmente cómo esto se aplica tanto a Bitcoin como a Kaspa.</p>
  <p><b>Grafo</b> - La teoría de grafos, un campo de las matemáticas y la informática, se centra en el estudio de los grafos, que son estructuras que representan relaciones entre pares de entidades. Estos grafos consisten en vértices (también llamados nodos o puntos) conectados por aristas (a veces llamadas enlaces o líneas). Los grafos se clasifican en grafos no dirigidos, donde las conexiones entre vértices son mutuas, y grafos dirigidos, donde las conexiones tienen una dirección específica. Como área clave de las matemáticas discretas, la teoría de grafos explora estas estructuras en profundidad. La siguiente imagen ilustra un grafo no dirigido simple donde las conexiones no tienen dirección.</p>
  <div class="img-container"><img alt="Grafo No Dirigido" src="images/image63.png"></div>
  <p><b>Grafo Dirigido</b> - Un grafo dirigido, a menudo llamado digrafo, es una estructura utilizada para mostrar relaciones donde las conexiones entre puntos tienen una dirección específica. A diferencia de los grafos regulares donde las conexiones van en ambos sentidos, en un grafo dirigido, cada arista apunta de un vértice a otro. En su forma más simple, un grafo dirigido consta de dos partes principales: una colección de vértices y un conjunto de aristas, donde cada arista es un par de vértices con una dirección clara (de un vértice a otro, pero no viceversa). Por ejemplo, si tiene una arista del vértice X al vértice Y, X es el punto de partida e Y es el punto final. Esta arista conecta X con Y. Una arista diferente podría ir de Y a X, pero esa sería una conexión distinta. En esta configuración básica, llamada grafo dirigido simple, no puede tener múltiples aristas con la misma dirección entre los mismos dos vértices, ni puede tener una arista que comience y termine en el mismo vértice (llamado bucle). La siguiente imagen ilustra un grafo dirigido donde las aristas tienen una dirección; tenga en cuenta que la arista con dos punteros representa dos aristas, cada una con una dirección.</p>
  <div class="img-container"><img alt="Grafo Dirigido" src="images/image70.png"></div>
  <p><b>Grafo Dirigido Acíclico</b> - es un grafo dirigido que no contiene ciclos. Está compuesto por vértices y aristas, donde cada arista tiene una dirección de un vértice a otro, asegurando que seguir las direcciones de las aristas nunca conduce a un bucle cerrado. Un grafo dirigido se llama DAG si sus vértices pueden organizarse en una secuencia lineal que respete la dirección de todas las aristas, conocida como orden topológico. La siguiente imagen ilustra un grafo dirigido acíclico donde no se puede encontrar ningún ciclo (o bucle).</p>
  <div class="img-container"><img alt="Grafo Dirigido Acíclico (DAG)" src="images/image7.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Grafo</b> - consta de vértices y aristas que conectan pares de vértices, donde los vértices representan cualquier tipo de objeto y las aristas representan las conexiones entre ellos.</p>
    <p><b>Grafo Dirigido</b> - cada arista tiene una dirección específica, apuntando de un vértice a otro. Un camino en un grafo dirigido es una secuencia de aristas donde el vértice final de una arista es el vértice inicial de la siguiente arista en la secuencia.</p>
    <p><b>Grafo Dirigido Acíclico</b> - un grafo dirigido donde ningún vértice puede alcanzarse a sí mismo a través de un camino que incluya una o más aristas, asegurando la ausencia de ciclos.</p>
    <p>Hay mucho más que aprender sobre los grafos, pero para nuestros propósitos, solo necesitamos saber que el BlockDAG de Kaspa es solo una estructura, compuesta por aristas y vértices, conectados en una sola dirección, y que nunca terminamos en un ciclo, es acíclico, o un Grafo Dirigido Acíclico.</p>
  </div>

  <h3 class="section-title" id="h.r0onrjvzaye8">Bitcoin y Kaspa</h3>
  <p><b>Bitcoin</b> - es un DAG, aunque siempre se le llama Blockchain, Bitcoin utiliza la estructura DAG. Los bloques son vértices y su relación es la de las aristas. Cada bloque está conectado en una sola dirección y, al seguir cada conexión, nunca formará un ciclo y siempre regresará al Génesis.</p>
  <div class="img-container"><img alt="Estructura de la cadena de bloques de Bitcoin como un DAG lineal" src="images/image25.png"></div>
  <p><b>Kaspa</b> - es un DAG, Kaspa utiliza la estructura DAG. Los bloques son vértices y su relación es la de las aristas. Cada bloque está conectado en una sola dirección y, al seguir cada conexión, nunca formará un ciclo y siempre regresará al Génesis.</p>
  <div class="img-container"><img alt="Estructura del BlockDAG de Kaspa" src="images/image30.png"></div>
  <p>Entonces, ¿cuál es la diferencia si tanto Bitcoin como Kaspa usan un DAG? Bitcoin permite que los bloques apunten a un solo bloque anterior. Kaspa permite que los bloques apunten a múltiples bloques anteriores. Esta es la única diferencia en la estructura.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.q9lxzgpefpuh">Capítulo 2: Kaspa - Vinculando el Cuerpo al Encabezado</h2>
  <div class="img-container"><img alt="Encabezado de bloque vinculado al cuerpo del bloque" src="images/image66.png"></div>
  <h3 class="section-title" id="h.3ezesbjpkjql">Asegurando el Cuerpo del Bloque al Encabezado - Raíz Merkle</h3>
  <p>¿Qué asegura el cuerpo del bloque al encabezado? La Raíz Merkle de las transacciones en el cuerpo.</p>
  <p>¿Qué significa eso? Este artículo está diseñado para no asumir conocimientos previos, por lo que comenzaremos con un Árbol Merkle. Qué es un árbol Merkle, cómo se construye y cómo evita la manipulación. Luego, cómo se aplica tanto a Bitcoin como a Kaspa.</p>
  <p><b>Árbol Merkle</b> - En criptografía y ciencias de la computación, un Árbol Merkle, también conocido como Árbol Hash, es una estructura similar a un árbol donde cada nodo "hoja" contiene el hash criptográfico de un bloque de datos. Los nodos no hoja, a menudo llamados ramas o nodos internos, contienen el hash criptográfico de las etiquetas de sus nodos hijos. Esta estructura permite una validación eficiente y segura del contenido de grandes conjuntos de datos.</p>
  <div class="img-container"><img alt="Estructura del árbol Merkle" src="images/image13.png"></div>
  <p><b>Bloque de Datos</b> - En un árbol Merkle, un bloque de datos es un segmento de datos brutos, como una transacción, que forma la base de la estructura del árbol. Cada bloque de datos se hash individualmente para producir un hash de nodo hoja.</p>
  <div class="img-container"><img alt="Hasheando transacciones para crear hojas" src="images/image9.png"></div>
  <p><b>Hoja</b> - Un nodo en un árbol Merkle que almacena el hash criptográfico de un solo bloque de datos. El nodo hoja, al almacenar este hash, actúa como una huella digital del bloque de datos.</p>
  <div class="img-container"><img alt="Hasheando transacciones para crear hojas" src="images/image23.png"></div>
  <p><b>Nodo Interno</b> - Un nodo padre que agrega los hashes de sus nodos hijos. Estos hashes hijos se concatenan y se hashean para producir un único valor hash que etiqueta el nodo interno.</p>
  <div class="img-container"><img alt="Hasheando hojas para crear nodos internos" src="images/image58.png"></div>
  <p><b>Raíz Hash</b> - El valor hash singular en el nodo más alto, que encapsula todos los datos del árbol. Sirve como un resumen compacto y único de todos los bloques de datos subyacentes. Cualquier modificación a un solo nodo hoja altera la raíz hash.</p>
  <div class="img-container"><img alt="Raíz Merkle, el hash final" src="images/image5.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Árbol Merkle</b> - Una estructura similar a un árbol utilizada para verificar eficientemente la integridad de los datos organizando bloques de datos en una estructura de hashes criptográficos.</p>
    <p><b>Bloque de Datos</b> - Una unidad de información, como una transacción, que se hashea para crear un nodo hoja.</p>
    <p><b>Hoja</b> - Un nodo que almacena el hash de un solo bloque de datos.</p>
    <p><b>Nodo Interno</b> - Un nodo padre que contiene el hash de sus nodos hijos.</p>
    <p><b>Raíz Hash</b> - El nodo más alto que contiene un único hash que representa la integridad de todo el conjunto de datos.</p>
  </div>

  <h3 class="section-title" id="h.emrhhaf2640n">Bitcoin y Kaspa</h3>
  <p><b>Bitcoin</b> - un Árbol Merkle organiza los datos de las transacciones dentro de cada bloque. Las transacciones se hashean en nodos hoja, se emparejan y se hashean en nodos internos, y se combinan en una única raíz hash almacenada en el encabezado del bloque. Esta estructura permite una verificación eficiente de la integridad de las transacciones.</p>
  <div class="img-container"><img alt="Árbol Merkle en Bitcoin" src="images/image18.png"></div>
  <p><b>Kaspa</b> - un Árbol Merkle organiza los datos de las transacciones dentro de cada bloque de la misma manera que Bitcoin. Sin embargo, Kaspa permite la coexistencia de bloques paralelos, donde el orden entre estos bloques en el DAG no se puede conocer. Un Árbol Merkle depende del orden. ¿Cómo resuelve esto Kaspa? Añadiendo un Árbol Merkle adicional.</p>
  <div class="img-container"><img alt="Árbol Merkle en Kaspa" src="images/image69.png"></div>
  <p>¿Qué asegura el cuerpo del bloque al encabezado? La Raíz Merkle de las transacciones en el cuerpo (<code>hash_merkle_root</code>).</p>
  <p>¿Qué asegura las transacciones del mergeset al encabezado? La Raíz Merkle de las transacciones en el mergeset (<code>accepted_id_merkle_root</code>). Esta segunda raíz permite la validación de transacciones de bloques paralelos que se fusionan, resolviendo así el problema de ordenamiento en un entorno DAG.</p>
  <div class="img-container"><img alt="Las dos raíces Merkle en un encabezado de bloque de Kaspa" src="images/image65.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.y0ik307h70q9">Capítulo 3: Kaspa y el "Problema de Escalabilidad de Bitcoin"</h2>
  <div class="img-container"><img alt="Ilustración del problema de escalabilidad" src="images/image53.png"></div>
  <h3 class="section-title" id="h.2jy3kmwufuue">Kaspa resolvió el "Problema de Escalabilidad de Bitcoin" - ¿Qué es?</h3>
  <p>¿Cuál es el Problema de Escalabilidad de Bitcoin y cómo lo resolvió Kaspa? A través de la inclusión.</p>
  <p>¿Qué significa eso? Este artículo está diseñado para no asumir conocimientos previos, por lo que comenzaremos con un Modelo Cliente-Servidor, luego la red Peer-to-Peer. Qué es una red P2P, cómo se ve y cómo se propagan los mensajes dentro de ella. Luego, cómo se aplica tanto a Bitcoin como a Kaspa.</p>
  <p><b>Modelo Cliente-Servidor</b> - En una red cliente-servidor, una arquitectura centralizada organiza la comunicación y el intercambio de recursos a través de una única computadora potente llamada servidor, que se conecta a múltiples dispositivos de usuario llamados clientes. Esta estructura garantiza una gestión eficiente pero depende en gran medida del servidor, lo que la hace vulnerable.</p>
  <div class="img-container"><img alt="Modelo Cliente-Servidor" src="images/image67.png"></div>
  <p><b>Red Peer-to-Peer (P2P)</b> - Una arquitectura descentralizada que permite la comunicación directa y el intercambio de recursos entre nodos interconectados. Cada par funciona como cliente y servidor, contribuyendo a la resiliencia y escalabilidad de la red sin depender de una autoridad central.</p>
  <div class="img-container"><img alt="Red Peer-to-Peer" src="images/image12.png"></div>
  <p><b>Tiempo de Propagación</b> - En una red P2P, el tiempo de propagación es la duración que tarda un dato (como un nuevo bloque) en viajar de un nodo a otros a través de la red. Durante este tiempo, diferentes nodos pueden tener diferentes vistas del estado de la red.</p>
  <div class="img-container"><img alt="Propagación de mensajes en una red P2P" src="images/image37.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Modelo Cliente-Servidor</b> - Una computadora central gestiona los datos para múltiples clientes.</p>
    <p><b>Peer-to-Peer (P2P)</b> - Múltiples computadoras comparten datos directamente entre sí sin una autoridad central.</p>
    <p><b>Nodo</b> - Una sola computadora que participa en una red P2P.</p>
    <p><b>Tiempo de Propagación</b> - El tiempo que tarda un dato en propagarse por la red.</p>
  </div>

  <h3 class="section-title" id="h.v4bl36mx6e0u">Bitcoin y Kaspa</h3>
  <p><b>Bitcoin</b> - Utiliza una red P2P. Sin embargo, su seguridad depende de que la tasa de creación de bloques (10 minutos) sea mucho más lenta que el tiempo de propagación. Si los bloques se crean demasiado rápido, muchos bloques son "huérfanos" (rechazados), lo que desperdicia trabajo y compromete la seguridad. Este es el "problema de escalabilidad".</p>
  <div class="img-container"><img alt="Bloques huérfanos en Bitcoin debido a la latencia de la red" src="images/image45.png"></div>
  <p><b>Kaspa</b> - Utiliza un protocolo inclusivo (GHOSTDAG) que permite que los bloques apunten a múltiples bloques anteriores. Si se crean bloques paralelos durante el tiempo de propagación, todos se incluyen en el DAG. No hay bloques huérfanos. Esto permite que la tasa de creación de bloques sea más rápida que el tiempo de propagación, resolviendo así el problema de escalabilidad mientras se mantiene la seguridad.</p>
  <div class="img-container"><img alt="Inclusión de bloques paralelos en Kaspa" src="images/image14.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.1tq8u5wwr5up">Capítulo 4: MuHash</h2>
  <div class="img-container"><img alt="Ilustración del concepto MuHash" src="images/image35.png"></div>
  <h3 class="section-title" id="h.ny65anmiz0s">¿Qué es MuHash y cómo lo usa Kaspa?</h3>
  <p>Una estructura para rastrear UTXOs y podar datos antiguos del cuerpo del bloque.</p>
  <p>¿Qué significa eso? Este artículo está diseñado para no asumir conocimientos previos, por lo que comenzaremos con MuHash. Qué es una estructura MuHash, cómo se calcula y cómo conserva las propiedades de la Multiplicación. Luego, cómo se aplica tanto a Bitcoin como a Kaspa.</p>
  <p><b>MuHash</b> - En sistemas criptográficos, MuHash (Hash Multiplicativo) es un algoritmo de hash especializado diseñado para calcular eficientemente un único valor hash a partir de un conjunto de elementos. Permite actualizaciones incrementales, lo que significa que los elementos se pueden agregar o eliminar sin volver a calcular todo el hash, lo que mejora el rendimiento en conjuntos de datos dinámicos.</p>
  <div class="img-container"><img alt="Agregando y eliminando elementos en un MuHash" src="images/image57.png"></div>
  <p><b>Numerador y Denominador</b> - MuHash utiliza dos contadores: un numerador que multiplica los elementos agregados y un denominador que multiplica los elementos eliminados. El estado final se obtiene "dividiendo" el numerador por el denominador (mediante la multiplicación por el inverso modular). El orden de las operaciones no importa, lo cual es crucial para el procesamiento paralelo.</p>
  <div class="img-container"><img alt="Cálculo MuHash con numerador y denominador" src="images/image2.png"></div>
  <div class="img-container"><img alt="Cálculo MuHash con numerador y denominador" src="images/image64.png"></div>
  <p><b>Restricción de Módulo Primo</b> - El número primo modular actúa como un límite matemático que mantiene tanto el numerador como el denominador dentro de un rango manejable durante todas las operaciones aritméticas. Cada multiplicación se realiza módulo un número primo, lo que significa que, sin importar cuántos elementos se agreguen o eliminen, los resultados siempre "envuelven" para permanecer dentro del campo finito.</p>
  <div class="img-container"><img alt="Restricción de Módulo Primo" src="images/image16.png"></div>
  <p><b>Inverso Modular</b> - El inverso modular es la operación matemática que hace posible la división en el campo finito utilizado por MuHash. Cuando necesita "dividir" el numerador por el denominador para obtener el resultado final del hash, en realidad multiplica el numerador por el inverso modular del denominador.</p>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>MuHash</b> - Una estructura para hashear rápidamente elementos en un conjunto, donde el orden no importa.</p>
    <p><b>Numerador</b> - El campo donde los elementos se multiplican cuando se agregan.</p>
    <p><b>Denominador</b> - El campo donde los elementos se multiplican cuando se eliminan.</p>
    <p><b>Restricción de Módulo Primo</b> - Un número primo que define el campo matemático donde tienen lugar todas las operaciones.</p>
    <p><b>Inverso Modular</b> - La operación que permite la "división" en un campo finito.</p>
    <p>MuHash es solo una estructura, compuesta por un numerador y un denominador, que permite el hash rápido de elementos en un conjunto en cualquier orden sin recalcular desde cero.</p>
  </div>

  <h3 class="section-title" id="h.focbph7aurgq">Bitcoin y Kaspa</h3>
  <p><b>Bitcoin</b> - Los nodos completos retienen todas las transacciones, incluidas las transacciones gastadas antiguas. La poda es difícil porque no existe un mecanismo eficiente para resumir de forma compacta y verificable el estado de las transacciones (el conjunto UTXO) sin retener datos históricos.</p>
  <div class="img-container"><img alt="Almacenamiento completo de la cadena de bloques de Bitcoin" src="images/image42.png"></div>
  <p><b>Kaspa</b> - Los nodos completos podan datos antiguos. Esta capacidad de podar datos antiguos requiere una forma de eliminar todos los datos de las transacciones de cada bloque Y asegurarlos criptográficamente a cada encabezado. Kaspa utiliza MuHash para eliminar datos de transacciones de los bloques (de modo que solo los encabezados DAG permanezcan después del punto de poda) y asegurarlos a cada encabezado. Este es un paso esencial para la poda. Kaspa separa los Datos de Transacción (UTXO) de los Datos de Consenso (Encabezados), lo que significa que Kaspa solo almacena Transacciones No Gastadas, en lugar de todas las transacciones realizadas. Esto reduce los requisitos de almacenamiento en comparación con Bitcoin.</p>
  <div class="img-container"><img alt="Almacenamiento de Kaspa podado con MuHash" src="images/image51.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.oy0kgniero14">Capítulo 5: Modelo UTXO de Kaspa</h2>
  <div class="img-container"><img alt="Ilustración del modelo UTXO" src="images/image74.png"></div>
  <h3 class="section-title" id="h.8nqvw067oam1">¿Qué es un UTXO y cómo lo usa Kaspa?</h3>
  <p>Una estructura para rastrear quién puede gastar qué Kaspa.</p>
  <p>¿Qué significa eso? Este artículo está diseñado para no asumir conocimientos previos, por lo que comenzaremos con el Modelo de Cuenta y el modelo UTXO, luego qué es un UTXO, qué contiene y cómo se gasta. Luego, cómo se aplica tanto a Bitcoin como a Kaspa.</p>
  <p><b>Modelo de Cuenta</b> - El Modelo de Cuenta se comporta como una cuenta bancaria tradicional al mantener un saldo y ofrecer operaciones familiares. Al igual que consultar el saldo de su banco, puede consultar las tenencias actuales de la cuenta, y de manera similar a cómo los bancos rastrean su historial de transacciones, la Cuenta gestiona su estado financiero. El sistema proporciona operaciones de cuenta estándar como recibir depósitos y realizar transferencias, con cada cuenta teniendo su propio identificador y nombre únicos para una fácil gestión. Hay varios tipos de cuenta disponibles para satisfacer diferentes necesidades, al igual que los bancos ofrecen varios tipos de cuenta para diferentes propósitos.</p>
  <div class="img-container"><img alt="Modelo de Cuenta" src="images/image52.png"></div>
  <p><b>Modelo UTXO</b> - El Modelo UTXO se comporta como dinero en efectivo o monedas físicas en su billetera, donde cada moneda tiene un valor específico y solo se puede gastar una vez. Así como podría tener varios billetes y monedas de diferentes denominaciones en su billetera física, una billetera digital contiene múltiples UTXO de diferentes cantidades que representan su saldo gastable. Cuando realiza una transacción, se consumen UTXO específicos como entradas (como gastar billetes exactos), y se crean nuevos UTXO como salidas para el destinatario y cualquier cambio que se le devuelva, de manera similar a cómo un cajero le da cambio cuando paga con un billete más grande. El sistema rastrea estas "monedas" individuales en todas las transacciones, manteniendo un registro completo de qué UTXO existen y se pueden gastar, al igual que el dinero físico se mueve de persona a persona mientras conserva su identidad individual.</p>
  <div class="img-container"><img alt="Modelo UTXO" src="images/image22.png"></div>
  <p><b>Estructura UTXO</b> - Un UTXO (Salida de Transacción No Gastada) se estructura como un recibo digital que contiene toda la información esencial necesaria para gastarlo, de manera similar a cómo un cheque contiene la cantidad, los detalles del destinatario y la información de autorización. Cada UTXO contiene la cantidad de valor que posee y define las condiciones de gasto. Así como una moneda física tiene su denominación estampada y puede verificarse como auténtica, cada UTXO lleva su valor y prueba criptográfica de propiedad, lo que lo convierte en una unidad de valor autocontenida que puede verificarse y gastarse de forma independiente. El sistema trata cada UTXO como un objeto discreto con su propio identificador único, lo que permite un seguimiento preciso de las unidades de valor individuales a medida que se mueven por la red.</p>
  <div class="img-container"><img alt="Estructura de un UTXO" src="images/image17.png"></div>
  <p><b>Gastar un UTXO</b> - Gastar un UTXO se comporta como usar dinero en efectivo, donde debe presentar el billete o la moneda exactos para realizar una compra, y una vez gastado, no se puede usar de nuevo. El proceso comienza localizando el UTXO específico que desea gastar y verificando su existencia en el conjunto UTXO, de manera similar a verificar que un billete en su billetera es auténtico y no está gastado. Al crear una transacción, hace referencia al UTXO por su identificador único y proporciona un script de firma que demuestra que tiene derecho a gastarlo. El sistema valida que el UTXO no se haya gastado previamente (evitando el doble gasto), verifica que cumple con las condiciones de gasto y luego elimina el UTXO del conjunto gastable mientras crea nuevos UTXO como salidas, completando la transferencia de valor de una parte a otra.</p>
  <div class="img-container"><img alt="Proceso de gasto de un UTXO" src="images/image31.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Modelo de Cuenta</b> - Un sistema que mantiene un único saldo por cuenta.</p>
    <p><b>Modelo UTXO</b> - Un sistema que rastrea "monedas" individuales de valor.</p>
    <p><b>UTXO</b> - Una salida de transacción no gastada, que representa una suma específica de dinero.</p>
    <p><b>Gastar un UTXO</b> - El proceso de consumir un UTXO para crear nuevos UTXO.</p>
    <p>Un UTXO es solo una estructura para rastrear quién puede gastar qué.</p>
  </div>

  <h3 class="section-title" id="h.5v09d76siagw">Bitcoin y Kaspa</h3>
  <p><b>Bitcoin</b> - Utiliza el modelo UTXO. Las transacciones son colecciones de UTXO consumidos y creados, almacenados en el cuerpo de cada bloque.</p>
  <div class="img-container"><img alt="Modelo UTXO en Bitcoin" src="images/image27.png"></div>
  <p><b>Kaspa</b> - También utiliza el modelo UTXO. La principal diferencia radica en cómo se gestionan y validan estos UTXO en un entorno BlockDAG, lo que permite el procesamiento paralelo y confirmaciones más rápidas.</p>
  <div class="img-container"><img alt="Modelo UTXO en Kaspa" src="images/image44.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.6x07cz5zmxim">Capítulo 6: Padres vs. Mergeset</h2>
  <div class="img-container"><img alt="Relaciones entre bloques en el DAG" src="images/image4.png"></div>
  <h3 class="section-title" id="h.34xcaoqpznos">¿Qué son Padres y Mergeset y cómo los usa Kaspa?</h3>
  <p>Dos formas diferentes de describir las relaciones entre bloques en la estructura BlockDAG de Kaspa.</p>
  <p><b>Padres de Blockchain Tradicional</b> - En una blockchain lineal como Bitcoin, cada bloque tiene exactamente un padre (excepto Génesis), creando una estructura de cadena simple. La relación parental es sencilla: cada nuevo bloque hace referencia al hash del bloque anterior, formando una secuencia ininterrumpida desde Génesis hasta la punta actual.</p>
  <div class="img-container"><img alt="Relación parental en Bitcoin" src="images/image34.png"></div>
  <p><b>Complejidad de los Padres DAG</b> - El BlockDAG de Kaspa permite que los bloques tengan múltiples padres, creando una red de relaciones más compleja. Cuando se crea un bloque, puede hacer referencia a varios bloques existentes como padres, lo que permite la creación de bloques paralelos y un mayor rendimiento.</p>
  <div class="img-container"><img alt="Múltiples relaciones parentales en Kaspa" src="images/image36.png"></div>
  <p><b>Padres</b> - Los padres son los bloques a los que un nuevo bloque hace referencia directamente en su encabezado. Estas son relaciones explícitas declaradas por el creador del bloque; son los bloques sobre los que este nuevo bloque se construye directamente. Cuando ve un Visualizador DAG de Kaspa, estas flechas representan la relación parental.</p>
  <div class="img-container"><img alt="Un nuevo bloque apuntando a sus padres" src="images/image11.png"></div>
  <p><b>Cómo Funcionan los Padres</b> - Al crear un bloque, los mineros seleccionan bloques existentes para referenciarlos como padres basándose en lo que consideran las "puntas" actuales del DAG. El sistema valida estas relaciones parentales y las utiliza para determinar la posición del bloque dentro de la estructura del DAG. Aquí, puede ver un nuevo bloque que se está creando, haciendo referencia a las "puntas" del DAG, los bloques encontrados sin que otro bloque apunte a ellos.</p>
  <div class="img-container"><img alt="Creando un nuevo bloque y seleccionando puntas" src="images/image56.png"></div>
  <p><b>Mergeset</b> - El mergeset es el conjunto de bloques que se encuentran en el anticono del padre seleccionado de un bloque pero que aún se consideran parte del contexto de consenso del bloque. Aquí, el bloque C está en el anticono de B, y el bloque B está en el anticono de C.</p>
  <div class="img-container"><img alt="Ilustración del mergeset de un bloque" src="images/image29.png"></div>
  <p><b>Cómo se Calcula el Mergeset</b> - El mergeset se calcula encontrando todos los bloques que no son ancestros del padre seleccionado pero que aún son alcanzables a través del conjunto de padres del bloque. Esto crea un contexto más amplio de bloques que deben considerarse para las decisiones de consenso. En este ejemplo, si el bloque B es el padre seleccionado, el mergeset del bloque que se está creando incluiría tanto el bloque C como el bloque D.</p>
  <div class="img-container"><img alt="Cálculo del Mergeset" src="images/image47.png"></div>
  <p><b>Mergeset en GHOSTDAG</b> - El protocolo GHOSTDAG procesa el mergeset para determinar qué bloques deben colorearse "azules" (contribuyendo al consenso) o "rojos" (válidos pero no contribuyendo). Este proceso de coloreado es esencial para mantener el consenso en el entorno de bloques paralelos.</p>

  <h3 class="section-title">Cómo trabajan juntos Padres y Mergeset</h3>
  <p><b>Selección del Padre Seleccionado</b> - Entre todos los padres, el sistema selecciona uno como el "padre seleccionado", el que tiene el mayor "trabajo azul". Esto crea una cadena principal a través del DAG mientras se reconocen otras relaciones parentales. Aquí, la cadena parental está resaltada.</p>
  <div class="img-container"><img alt="Selección de padre seleccionado y cadena principal" src="images/image75.png"></div>
  <p><b>Procesamiento del Mergeset</b> - Una vez que se elige el padre seleccionado, el mergeset se calcula y procesa para determinar los datos finales de GHOSTDAG. El mergeset excluye al padre seleccionado, ya que ya está contabilizado en la cadena principal. Aquí, el mergeset incluye el bloque C, ya que está en el anticono del bloque B (el padre seleccionado) aunque no es un padre del nuevo bloque (los padres solo incluyen el bloque B y el bloque D).</p>
  <div class="img-container"><img alt="Procesamiento del Mergeset" src="images/image26.png"></div>
  <p><b>Selección de Padre Virtual</b> - Al crear el estado virtual, el sistema utiliza ambos conceptos: elige padres virtuales de bloques candidatos mientras se asegura de que el mergeset resultante no exceda los límites de tamaño. Esto equilibra la inclusión de muchos bloques paralelos mientras se mantiene una complejidad de consenso manejable.</p>

  <h3 class="section-title">Diferencias Prácticas</h3>
  <p><b>Almacenamiento e Iteración</b> - Los padres se almacenan directamente en los encabezados de los bloques, mientras que los datos del mergeset se calculan y almacenan por separado en las estructuras de datos de GHOSTDAG. El sistema proporciona diferentes iteradores para acceder a los bloques del mergeset en varios órdenes (orden de consenso, orden de "trabajo azul", etc.).</p>
  <p><b>Impacto en el Consenso</b> - Los padres determinan la estructura básica del DAG, pero el mergeset determina qué bloques realmente contribuyen a los cálculos de consenso como la "puntuación azul" y el "trabajo azul". Un bloque podría ser un padre pero terminar siendo coloreado de rojo en el mergeset, lo que significa que no contribuye a la cadena de consenso principal.</p>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Padres</b> - Los bloques a los que un nuevo bloque hace referencia directamente en su encabezado, estableciendo relaciones explícitas en el DAG.</p>
    <p><b>Mergeset</b> - El conjunto de bloques en el anticono de un bloque que se consideran para el procesamiento de consenso, excluyendo al padre seleccionado.</p>
    <p><b>Padre Seleccionado</b> - El padre con el mayor "trabajo azul", formando la columna vertebral de la cadena principal.</p>
    <p><b>Mergeset Azul/Rojo</b> - Bloques en el mergeset que contribuyen al consenso (azul) o no (rojo).</p>
    <p>Los padres definen la estructura del DAG, mientras que el mergeset determina la participación en el consenso.</p>
  </div>

  <h3 class="section-title" id="h.tsab66lazd4a">Bitcoin vs. Kaspa</h3>
  <p><b>Bitcoin</b> - Tiene solo un padre por bloque (excepto Génesis), por lo que no hay distinción entre padres y mergeset. El único padre es tanto la relación estructural como la de consenso.</p>
  <div class="img-container"><img alt="Estructura simple de Bitcoin" src="images/image55.png"></div>
  <p><b>Kaspa</b> - Separa las relaciones estructurales (padres) de las relaciones de consenso (mergeset). Múltiples padres crean la estructura DAG, pero el procesamiento del mergeset determina qué bloques realmente contribuyen al estado de consenso.</p>
  <div class="img-container"><img alt="Estructura compleja de Kaspa con padres y mergeset" src="images/image24.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.x0nj4tecoh66">Capítulo 7: Poda de Segundo Orden</h2>
  <div class="img-container"><img alt="Ilustración de la poda de segundo orden" src="images/image48.png"></div>
  <h3 class="section-title" id="h.1wbq42gt63wc">¿Qué es la poda de segundo orden y cómo la usa Kaspa?</h3>
  <p>La poda de segundo orden es el paso avanzado en la optimización del almacenamiento de Kaspa que elimina los datos relacionados con el consenso mientras mantiene la capacidad de validar nuevos bloques y participar en el consenso de la red. Va más allá de la poda de primer orden al eliminar selectivamente los datos de la estructura DAG, las relaciones y algunos encabezados.</p>
  <p>¿Por qué "Segundo Orden"? - Esta terminología enfatiza que después de que se eliminan los cuerpos de los bloques (Primer Orden), Kaspa puede eliminar datos de consenso adicionales mientras conserva las capacidades de validación. La poda de segundo orden permite la máxima eficiencia de almacenamiento al eliminar información de consenso redundante que no es esencial para la validación continua.</p>
  <p>¿Qué significa eso? - Este artículo asume el conocimiento de la poda de primer orden, por lo que comenzaremos con los datos de consenso que existen después de la poda de primer orden, luego explicaremos cómo la poda de segundo orden elimina selectivamente las estructuras de consenso, qué se retiene frente a qué se elimina, y cómo la validación continúa funcionando con datos de consenso reducidos.</p>

  <h3 class="section-title">Poda de Primer Orden vs. Poda de Segundo Orden</h3>
  <p><b>Fundamento de la Poda de Primer Orden</b> - Después de la poda de primer orden, los nodos retienen todos los encabezados de los bloques, los datos de GHOSTDAG, las relaciones de accesibilidad y la información de la estructura DAG. Esto permite una validación de consenso completa, pero aún requiere un almacenamiento significativo para las complejas relaciones DAG que mantiene Kaspa.</p>
  <p><b>Desafío de la Poda de Segundo Orden</b> - El desafío es determinar qué datos de consenso se pueden eliminar de forma segura sin comprometer la capacidad del nodo para validar nuevos bloques. El sistema debe preservar suficiente información estructural para mantener el consenso mientras elimina datos redundantes.</p>

  <h3 class="section-title">Sistema de Prueba Multinivel</h3>
  <p><b>Clasificación de Nivel de Prueba</b> - El sistema de poda de Kaspa clasifica los bloques según su importancia para diferentes niveles de prueba. Los bloques afiliados a niveles de prueba más altos retienen más datos de consenso que aquellos que solo se necesitan para niveles más bajos.</p>
  <p><b>Retención de Datos Basada en Niveles</b> - El sistema determina qué datos de consenso retener en función del nivel de prueba al que pertenece cada bloque. Los bloques de nivel superior retienen más relaciones e información de consenso, mientras que los bloques de nivel inferior pueden tener sus datos de consenso eliminados de forma segura.</p>
  <p><b>Zonas DAG Contiguas</b> - La poda garantiza que para cada nivel, las relaciones restantes representen una zona DAG contigua, manteniendo la integridad estructural necesaria para la validación del consenso.</p>

  <h3 class="section-title">Qué se elimina en la Poda de Segundo Orden</h3>
  <p><b>Eliminación de Datos de Relación</b> - La poda de segundo orden elimina los datos de relación específicos del nivel para los bloques que solo pertenecen a niveles de prueba superiores. Esto preserva la semántica de que las relaciones representan zonas DAG contiguas mientras se eliminan datos innecesarios de nivel inferior.</p>
  <p><b>Eliminación Selectiva de Datos GHOSTDAG</b> - El sistema elimina los datos GHOSTDAG para ciertos bloques mientras los preserva para la validación de consenso esencial. Los datos GHOSTDAG se eliminan en el nivel 0 para los bloques parcialmente podados.</p>
  <p><b>Eliminación de Encabezados</b> - En la forma más agresiva de poda de segundo orden, algunos encabezados de bloques pueden eliminarse mientras se preservan los puntos de poda anteriores. Solo se eliminan los encabezados no esenciales para las consultas de puntos de poda.</p>

  <h3 class="section-title">Qué se retiene en la Poda de Segundo Orden</h3>
  <p><b>Estructuras de Consenso Esenciales</b> - Los datos de consenso críticos, como el anticono del punto de poda, los bloques de la ventana DAA y los bloques GHOSTDAG para la validación esencial, siempre se retienen. Esto garantiza que las operaciones de consenso puedan continuar incluso con un almacenamiento de datos reducido.</p>
  <p><b>Afiliaciones de Nivel de Prueba</b> - Los bloques mantienen su clasificación en función de la importancia del nivel de prueba, lo que determina qué datos se retienen. El sistema preserva los datos mínimos necesarios para la validación del consenso en función de estas afiliaciones.</p>
  <p><b>Puntos de Poda Pasados</b> - Los encabezados de los puntos de poda pasados siempre se retienen para mantener la capacidad de responder a las consultas de puntos de poda y admitir el sistema de prueba de poda.</p>

  <h3 class="section-title">Cómo continúa la Validación de Consenso</h3>
  <p><b>Transiciones de Estado</b> - Los bloques que se someten a poda de segundo orden pasan a un estado de "solo encabezado" cuando tenían un estado válido y pertenecen a un nivel de prueba. Esto preserva la semántica de que un estado válido implica la existencia de datos de consenso esenciales.</p>
  <p><b>Validación de Datos Reducidos</b> - Incluso con la poda de segundo orden, los nodos pueden validar nuevos bloques utilizando las estructuras de datos de consenso preservadas y las relaciones restantes. El sistema mantiene suficiente información para verificar las reglas GHOSTDAG y las relaciones entre bloques.</p>
  <p><b>Validación Basada en Pruebas</b> - Los datos de nivel de prueba preservados permiten a los nodos validar bloques utilizando pruebas criptográficas en lugar de datos de consenso históricos completos, lo que permite la participación en el consenso con un almacenamiento significativamente reducido.</p>

  <h3 class="section-title">Nodos de Archivo vs. Nodos de Poda</h3>
  <p><b>Comportamiento del Nodo de Archivo</b> - Los nodos configurados como archivo ignoran por completo la poda de primer y segundo orden, preservando todos los datos de consenso. Estos nodos sirven como un libro de contabilidad de consenso completo de la red, pero requieren el máximo almacenamiento.</p>
  <p><b>Eficiencia del Nodo de Poda</b> - Los nodos de poda regulares utilizan la poda de segundo orden para lograr la máxima eficiencia de almacenamiento mientras mantienen capacidades de validación de consenso completas a través del sistema de prueba multinivel.</p>
  <p>Nota: Para una explicación detallada de cómo los nodos de poda siguen siendo nodos completos y por qué los nodos de archivo son opcionales para el funcionamiento de la red (manteniendo el modelo sin confianza de Bitcoin), consulte el artículo extendido "Nodo de Archivo vs. Nodo Completo", que cubre las capacidades de validación, las pruebas criptográficas y la sostenibilidad de la red.</p>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Poda de Segundo Orden</b> - Eliminación de datos relacionados con el consenso mientras se conserva suficiente información para validar las reglas de consenso.</p>
    <p><b>Afiliación de Nivel de Prueba</b> - Clasificación de bloques basada en los niveles de prueba a los que pertenecen, determinando qué datos de consenso se retienen.</p>
    <p><b>Estado de "Solo Encabezado"</b> - Bloques cuyos datos de consenso han sido podados pero conservan información de validación esencial.</p>
    <p><b>Zonas DAG Contiguas</b> - Mantener la integridad estructural en los datos de consenso restantes después de la poda.</p>
    <p>La poda de segundo orden permite la máxima eficiencia de almacenamiento mientras preserva las capacidades de validación de consenso a través de la clasificación inteligente de datos.</p>
  </div>

  <h3 class="section-title">Bitcoin vs. Kaspa: Poda de Datos de Consenso</h3>
  <p><b>Bitcoin</b> - La información de consenso es esencial para la validación y no se puede eliminar de forma segura.</p>
  <p><b>Kaspa</b> - La compleja estructura DAG y el sistema de prueba multinivel permiten una sofisticada poda de segundo orden donde diferentes niveles de datos de consenso pueden eliminarse selectivamente según su importancia para la validación. Esto permite una optimización de almacenamiento mucho más agresiva mientras se mantienen las capacidades de consenso.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.mz2dlkhrvwd2">Capítulo 8: GHOSTDAG de Kaspa Simplificado</h2>
  <div class="img-container"><img alt="Ilustración de GHOSTDAG" src="images/image43.png"></div>
  <h3 class="section-title" id="h.hwkbrs8egi6p">¿Qué es GHOSTDAG y cómo lo usa Kaspa?</h3>
  <p>Un protocolo de consenso que ordena bloques en una estructura DAG mientras mantiene propiedades de seguridad.</p>
  <p>¿Qué significa eso? Este artículo explica GHOSTDAG comenzando con el consenso tradicional, luego el enfoque de GHOSTDAG, cómo clasifica los bloques y cómo difiere entre Bitcoin y Kaspa.</p>

  <h3 class="section-title">Consenso Tradicional - Orden de Cadena Lineal</h3>
  <p>El consenso tradicional de blockchain opera en una cadena lineal donde los bloques forman una secuencia única. Cada bloque tiene exactamente un padre (excepto Génesis), creando un mecanismo de ordenamiento simple. Cuando surgen conflictos (múltiples bloques a la misma altura), la red selecciona un bloque y rechaza los demás como huérfanos. Este enfoque garantiza un ordenamiento claro pero limita el rendimiento, ya que solo se puede aceptar un bloque en cada nivel.</p>
  <div class="img-container"><img alt="Consenso tradicional" src="images/image32.png"></div>

  <h3 class="section-title">Protocolo GHOSTDAG - Consenso DAG</h3>
  <p>GHOSTDAG extiende el consenso para trabajar con estructuras de Grafo Dirigido Acíclico (DAG) donde los bloques pueden tener múltiples padres. El protocolo procesa los bloques seleccionando primero un padre con el "Trabajo Azul" más alto, luego examinando todos los bloques en el Mergeset para clasificarlos como "azules" (honestos) o "rojos" (potencialmente conflictivos). Esta clasificación se basa en restricciones matemáticas que involucran el parámetro de seguridad K, que limita el tamaño de los Anticonos para mantener las propiedades de seguridad.</p>
  <div class="img-container"><img alt="Protocolo GHOSTDAG" src="images/image40.png"></div>

  <h3 class="section-title">Reglas de Clasificación de Bloques</h3>
  <p>GHOSTDAG clasifica los bloques utilizando dos restricciones clave relacionadas con el parámetro de seguridad K. Primero, el número de bloques azules en el Anticono de un bloque candidato no debe exceder K bloques. Segundo, para cada bloque azul existente, agregar el candidato no debe hacer que el Anticono de ningún bloque azul exceda K bloques. El algoritmo rastrea el tamaño del Anticono para validar eficientemente estas restricciones durante el procesamiento del bloque. El bloque gris aquí se está validando actualmente por la red, el bloque C es su Padre Seleccionado. Si k=0, entonces el bloque de cadena C ya es 1 bloque azul, lo que hace que el bloque B se clasifique como Rojo. Si k = 1 (o más), el bloque B se clasifica como azul, ya que solo tiene 1 bloque azul (bloque C) en su Anticono.</p>
  <div class="img-container"><img alt="Reglas de clasificación de bloques" src="images/image28.png"></div>

  <h3 class="section-title">Acumulación de Trabajo Azul</h3>
  <p>El protocolo acumula la prueba de trabajo solo de los bloques azules, creando la métrica "Trabajo Azul". Los bloques azules contribuyen con su trabajo computacional a la puntuación de seguridad acumulada, mientras que los bloques rojos se excluyen de este cálculo. Esta acumulación selectiva garantiza que solo los bloques válidos por consenso contribuyan a la seguridad de la red, evitando que los bloques maliciosos o conflictivos socaven el sistema. En este ejemplo, asumiendo que el bloque B es rojo (k=0), el "Trabajo Azul" de nuestro bloque gris se calcularía como el "Trabajo Azul" heredado del bloque C, más el "Trabajo Azul" del bloque C. Si el bloque B es azul, el "Trabajo Azul" de nuestro nuevo bloque heredaría el "Trabajo Azul" de su Padre Seleccionado (bloque C), luego agregaría el "Trabajo Azul" de su Padre Seleccionado (C) y el "Trabajo Azul" de los bloques azules en su Mergeset (bloque B).</p>
  <div class="img-container"><img alt="Acumulación de Trabajo Azul" src="images/image62.png"></div>

  <h3 class="section-title">Selección y Ordenamiento de Padres</h3>
  <p>GHOSTDAG determina el orden de los bloques mediante la selección de padres basada en los valores de "Trabajo Azul". El protocolo selecciona al padre con el mayor "Trabajo Azul" acumulado como el "Padre Seleccionado", creando una cadena troncal dentro de la estructura DAG. El ordenamiento de los bloques utiliza el "Trabajo Azul" como criterio principal, con el hash del encabezado del bloque proporcionando un ordenamiento determinista en caso de empates. En nuestro ejemplo, asumimos que el bloque C es el Padre Seleccionado y el bloque B es azul. El ordenamiento para el procesamiento de transacciones es 1. Padre Seleccionado (C) 2. Mergeset Ordenado (B)</p>
  <div class="img-container"><img alt="Selección y ordenamiento de padres" src="images/image6.png"></div>

  <h3 class="section-title">Almacenamiento y Gestión de Datos</h3>
  <p>El protocolo almacena los resultados de la clasificación en datos estructurados que contienen listas de bloques azules y rojos. Los bloques azules se agregan con seguimiento del tamaño del Anticono para futuras decisiones de clasificación, mientras que los bloques rojos simplemente se agregan a la lista roja. Esta organización mantiene la información completa del DAG mientras distingue claramente los roles de consenso.</p>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Consenso Tradicional</b> - Un sistema de ordenamiento de cadena lineal donde los bloques forman una secuencia única con un padre por bloque.</p>
    <p><b>Protocolo GHOSTDAG</b> - Un mecanismo de consenso DAG que clasifica los bloques como azules o rojos basándose en las restricciones de tamaño del Anticono.</p>
    <p><b>Clasificación de Bloques</b> - El proceso de determinar si los bloques son azules (válidos por consenso) o rojos (potencialmente conflictivos).</p>
    <p><b>Acumulación de Trabajo Azul</b> - Un conteo selectivo de la prueba de trabajo que solo incluye el trabajo de los bloques azules.</p>
    <p>GHOSTDAG es un protocolo de consenso que habilita las estructuras DAG mientras mantiene las propiedades de seguridad de la blockchain.</p>
  </div>

  <h3 class="section-title">Bitcoin y Kaspa</h3>
  <p><b>Bitcoin</b> - Utiliza el consenso de cadena lineal tradicional donde los bloques forman una secuencia única. Los bloques conflictivos son huérfanos y no contribuyen a la seguridad. La cadena más larga (trabajo más acumulado) determina el consenso a través de un mecanismo de comparación simple.</p>
  <div class="img-container"><img alt="Bitcoin y GHOSTDAG" src="images/image71.png"></div>
  <p><b>Kaspa</b> - Utiliza el protocolo GHOSTDAG para gestionar estructuras DAG con múltiples bloques concurrentes. Los bloques azules contribuyen a la seguridad a través de la acumulación de "Trabajo Azul", mientras que los bloques rojos permanecen en el DAG pero se excluyen de las decisiones de consenso. El protocolo mantiene ambos tipos de bloques para un seguimiento completo del estado de la red.</p>
  <div class="img-container"><img alt="Kaspa y GHOSTDAG" src="images/image19.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.drxg3f8wwuwc">Capítulo 9: Terminología DAG</h2>
  <div class="img-container"><img alt="Terminología DAG" src="images/image8.png"></div>
  <h3 class="section-title">Pasado, Futuro, Anticono, Mergeset, parámetro K, ¿qué significa todo esto?</h3>
  <p>Pasado, Futuro y Anticono son términos DAG, mientras que Mergeset y K se usan en GHOSTDAG.</p>
  <p>La terminología DAG es un vocabulario especializado para describir relaciones en una estructura BlockDAG. Comenzaremos con la cadena lineal, el DAG, luego un poco de GHOSTDAG.</p>

  <h3 class="section-title">Terminología de Cadena Lineal - Blockchain Tradicional</h3>
  <p>La terminología de cadena lineal utiliza conceptos simples donde los bloques forman una secuencia única. Cada bloque tiene un padre y potencialmente un hijo, creando relaciones simples de ancestro-descendiente. Términos como "altura", "bloque anterior" y "bloque siguiente" describen la progresión lineal. Cuando surgen conflictos, los bloques son "aceptados" en la cadena principal o "huérfanos" y descartados.</p>
  <div class="img-container"><img alt="Terminología de cadena lineal" src="images/image15.png"></div>

  <h3 class="section-title">Terminología DAG</h3>
  <p>Permitir que los bloques tengan múltiples padres crea nuevas relaciones dentro del DAG.</p>
  <div class="img-container"><img alt="Terminología DAG" src="images/image50.png"></div>

  <h3 class="section-title">Relaciones Pasado y Futuro - DAG</h3>
  <p>La relación Pasado define todos los bloques alcanzables siguiendo los enlaces padre hacia atrás desde un bloque dado. Un bloque está en el pasado de otro si hay un camino dirigido que los conecta. La relación Futuro funciona a la inversa: si el bloque A está en el pasado del bloque B, entonces B está en el futuro de A.</p>
  <div class="img-container"><img alt="Relaciones Pasado y Futuro - DAG" src="images/image73.png"></div>

  <h3 class="section-title">Relación Anticono - DAG</h3>
  <p>El Anticono describe bloques que no son ni ancestros ni descendientes entre sí; existen concurrentemente en el DAG. Dos bloques están en el Anticono del otro si ninguno puede alcanzar al otro a través de un camino dirigido. Esta relación es crucial para el parámetro de seguridad K de GHOSTDAG, que limita el tamaño de los Anticonos para mantener la seguridad del consenso. Aquí, el bloque B y el bloque C están en el Anticono del otro, el bloque B no es alcanzable desde el bloque C, y el bloque C no es alcanzable desde el bloque B.</p>
  <div class="img-container"><img alt="Relación Anticono - DAG" src="images/image59.png"></div>

  <h3 class="section-title">Mergeset y Clasificación Azul/Roja - GHOSTDAG</h3>
  <p>El Mergeset se refiere a la colección de bloques que se fusionan cuando se crea un nuevo bloque. El Mergeset contiene los padres directos de un bloque, pero también puede contener bloques que no son padres directos. GHOSTDAG clasifica los bloques en el Mergeset como "Azules" (honestos) o "Rojos" (potencialmente conflictivos) basándose en las restricciones de tamaño del Anticono. Esta clasificación determina qué bloques contribuyen a la seguridad de la red a través de la acumulación de "Trabajo Azul". Aquí hay un ejemplo del bloque B clasificando su Mergeset como Azul y Rojo cuando la restricción de tamaño del Anticono = 0.</p>
  <div class="img-container"><img alt="Mergeset y Clasificación Azul/Roja - GHOSTDAG" src="images/image46.png"></div>

  <h3 class="section-title">Parámetro K - GHOSTDAG</h3>
  <p>El parámetro K controla el tamaño máximo permitido del Anticono para los bloques azules. Este parámetro se calcula en función de la latencia de la red, la tasa de producción de bloques y las garantías de seguridad deseadas. En este ejemplo, en lugar de k = 0 como en el ejemplo anterior, k = 1, por lo que cada bloque azul tiene 1 bloque azul más en su Anticono.</p>
  <div class="img-container"><img alt="Parámetro K - GHOSTDAG" src="images/image61.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Relación Pasado</b> - Todos los bloques alcanzables siguiendo los enlaces padre hacia atrás desde un bloque dado.</p>
    <p><b>Relación Futuro</b> - Todos los bloques que pueden alcanzar un bloque dado siguiendo los enlaces padre hacia adelante.</p>
    <p><b>Relación Anticono</b> - Bloques que no son ni ancestros ni descendientes entre sí.</p>
    <p><b>Mergeset</b> - Colección de bloques GHOSTDAG fusionados cuando se crea un nuevo bloque.</p>
    <p><b>Clasificación Azul/Roja</b> - Categorización de bloques por GHOSTDAG como honestos (azules) o potencialmente conflictivos (rojos).</p>
    <p><b>Parámetro de Seguridad K</b> - Tamaño máximo permitido del anticono de GHOSTDAG para mantener la seguridad del consenso.</p>
  </div>

  <h3 class="section-title">Bitcoin y Kaspa</h3>
  <p><b>Bitcoin</b> - Utiliza una terminología lineal simple: "bloque anterior", "bloque siguiente", "altura de la cadena" y "cadena más larga". Las relaciones son conexiones simples de ancestro-descendiente. Los bloques en competencia son "huérfanos" sin estados intermedios.</p>
  <div class="img-container"><img alt="Bitcoin y terminología" src="images/image54.png"></div>
  <p><b>Kaspa</b> - Utiliza terminología adicional, incluyendo las relaciones Pasado/Futuro/Anticono del DAG, el Mergeset de GHOSTDAG y la clasificación Azul/Roja del Mergeset. Kaspa mantiene múltiples bloques concurrentes, gestiona sus relaciones y proporciona un ordenamiento consistente.</p>
  <div class="img-container"><img alt="Kaspa y terminología" src="images/image49.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.1uals18cttyl">Capítulo 10: Poda de Primer Orden</h2>
  <div class="img-container"><img alt="Ilustración de la poda de primer orden" src="images/image41.png"></div>
  <h3 class="section-title" id="h.3i8fyh1jrh8m">¿Qué es la poda de primer orden y cómo la usa Kaspa?</h3>
  <p>La poda de primer orden es el primer paso en la optimización de almacenamiento multifase de Kaspa. Elimina datos de transacciones antiguos de los bloques mientras mantiene un conjunto UTXO en el punto de poda para la validación del estado, pero, crucialmente, preserva todos los encabezados de los bloques para mantener la integridad de la cadena de bloques.</p>
  <p>¿Por qué "Primer Orden"? - Esta terminología enfatiza que la eliminación de los cuerpos de los bloques es solo el comienzo. Si bien la poda de primer orden reduce significativamente los requisitos de almacenamiento y disminuye las barreras para ejecutar un nodo (aumentando la descentralización), le siguen pasos de poda adicionales que pueden eliminar aún más datos (poda de segundo orden). Este artículo se centra específicamente en la eliminación del cuerpo del bloque, la base que hace posible todas las optimizaciones posteriores.</p>
  <p>¿Qué significa eso? - Este artículo no asume conocimientos previos, por lo que comenzaremos con los desafíos tradicionales de almacenamiento de blockchain, luego explicaremos cómo funciona la poda de primer orden manteniendo conjuntos UTXO, qué se elimina frente a qué se preserva, cómo el conjunto UTXO del punto de poda permite la validación, y cómo esto crea la base para el modelo de almacenamiento escalable de Kaspa que permite una participación más amplia en la red.</p>

  <h3 class="section-title">Almacenamiento Tradicional vs. Poda de Primer Orden</h3>
  <p><b>Almacenamiento Completo Tradicional</b> - En las implementaciones tradicionales de blockchain, los nodos almacenan datos de bloques completos, incluidos todos los detalles de las transacciones desde Génesis hasta la punta actual. Esto significa que cada entrada, salida, firma y script de transacción se conserva para siempre, lo que lleva a requisitos de almacenamiento cada vez mayores que pueden volverse prohibitivos para muchos usuarios.</p>
  <p><b>Desafío de la Poda de Primer Orden</b> - El desafío es eliminar datos de transacciones antiguos sin dejar de poder validar nuevas transacciones. Las nuevas transacciones deben hacer referencia a salidas anteriores (UTXO), por lo que el sistema debe mantener suficiente información para validar estas referencias incluso después de que se podan los cuerpos de los bloques antiguos.</p>

  <h3 class="section-title">El conjunto UTXO como base</h3>
  <p><b>Definición del conjunto UTXO</b> - El conjunto UTXO representa todas las salidas de transacción no gastadas en un punto específico de la cadena de bloques. Una instantánea de todas las "monedas" que existen y se pueden gastar en ese momento, similar a un inventario de todo el dinero en circulación.</p>
  <p><b>Conjunto UTXO del Punto de Poda</b> - Kaspa mantiene un conjunto UTXO especial en el Punto de Poda, que sirve como estado base para la validación. Este conjunto UTXO se actualiza a medida que avanza el Punto de Poda, asegurando que siempre refleje el estado gastable correcto en ese punto de control.</p>
  <p><b>Avance del Conjunto UTXO</b> - Cuando el Punto de Poda avanza, el sistema aplica las diferencias de UTXO de los bloques en la cadena para actualizar el conjunto UTXO del punto de poda. Este proceso garantiza que el conjunto UTXO permanezca preciso a medida que se podan los datos antiguos.</p>

  <h3 class="section-title">Qué se poda en la Poda de Primer Orden</h3>
  <p><b>Eliminación de Datos del Cuerpo del Bloque</b> - La poda de primer orden elimina los datos reales de las transacciones de los bloques antiguos, incluidas las entradas, salidas, firmas y scripts de las transacciones. Esto incluye los multisets UTXO, las diferencias UTXO, los datos de aceptación y el almacenamiento completo de las transacciones del bloque.</p>
  <p><b>Preservación del Encabezado</b> - Aunque se eliminan los datos de las transacciones, los encabezados de los bloques se preservan para mantener la integridad estructural de la cadena de bloques. Los bloques pasan a un estado de "solo encabezado", lo que indica que el encabezado existe pero el cuerpo ha sido podado.</p>
  <p><b>Retención de Datos Esenciales</b> - El sistema preserva los datos críticos necesarios para la validación del consenso, incluido el anticono del punto de poda, los bloques de la ventana DAA y los bloques GHOSTDAG. Esto garantiza que las operaciones de consenso puedan continuar incluso después de la poda.</p>

  <h3 class="section-title">Cómo el conjunto UTXO permite la validación</h3>
  <p><b>Proceso de Validación de Transacciones</b> - Las nuevas transacciones se pueden validar contra el conjunto UTXO del punto de poda más todos los cambios UTXO posteriores. El sistema valida que los UTXO referenciados existen y no se han gastado dos veces, incluso sin los datos de transacción originales.</p>
  <p><b>Reconstrucción del Estado</b> - El conjunto UTXO en el punto de poda, combinado con las diferencias UTXO de los bloques posteriores, permite la reconstrucción del estado gastable actual. Esto permite capacidades de validación completas sin requerir datos de transacciones históricos completos.</p>
  <p><b>Verificación de Compromiso</b> - El sistema puede verificar la integridad del conjunto UTXO utilizando compromisos criptográficos en los encabezados de los bloques. Esto garantiza que el conjunto UTXO podado coincida con lo que los encabezados de la cadena de bloques afirman que debería ser.</p>

  <h3 class="section-title">Nodos de Archivo vs. Nodos de Poda</h3>
  <p><b>Comportamiento del Nodo de Archivo</b> - Los nodos configurados como archivo ignoran por completo la poda de primer orden, preservando todos los datos de las transacciones. Estos nodos sirven como un libro de contabilidad histórico completo de la red, pero requieren significativamente más almacenamiento.</p>
  <p><b>Eficiencia del Nodo de Poda</b> - Los nodos de poda regulares utilizan la poda de primer orden para mantener un almacenamiento manejable mientras participan plenamente en la validación del consenso. El conjunto UTXO proporciona suficiente información para validar nuevas transacciones sin requerir datos históricos completos.</p>

  <h4 class="subsection-title">Abordando las preocupaciones sobre la poda y la prueba de génesis</h4>
  <p>Una preocupación recurrente es que las lagunas en el historial del libro mayor debido a la poda podrían comprometer la verificabilidad de la cadena desde su inicio (el bloque génesis), y particularmente la prueba de que no hubo pre-minado.</p>
  <p>Esta preocupación es infundada. He aquí por qué:</p>
  <ol>
      <li><strong>El bloque génesis está integrado en el código:</strong> El bloque génesis en sí está "codificado" en el software del nodo Kaspa. Este bloque génesis contiene un conjunto UTXO vacío, lo que demuestra que no hubo pre-minado. Cualquier usuario puede verificar esto en el código fuente público.</li>
      <li><strong>La prueba de génesis:</strong> Cada nodo mantiene una "prueba de génesis". Esta es una cadena corta de datos que prueba criptográficamente que el estado actual del libro mayor ha evolucionado a partir del bloque génesis incrustado. Forjar tal prueba requeriría tanto trabajo como el invertido para crear todo el libro mayor. En otras palabras, esta prueba es tan sólida como poseer el historial completo.</li>
      <li><strong>La integridad del historial reconstruido:</strong> Aunque se hacen esfuerzos para reconstruir el historial completo con fines de investigación y conveniencia, el proceso está descentralizado. Los datos se recopilan de muchos usuarios. Ningún actor individual tiene control sobre las "lagunas" restantes, lo que hace imposible "ocultar" selectivamente una parte del historial.</li>
  </ol>
  <p>En resumen, el mecanismo de poda de Kaspa está diseñado para que la red permanezca segura, protegida y transparente, incluso sin ningún nodo de archivo. La verificabilidad de la cadena desde su génesis está garantizada por pruebas criptográficas robustas, y no por la necesidad de almacenar un historial completo y cada vez más pesado.</p>

  <div class="simplified-def">
    <h3 class="section-title">Definiciones Simplificadas</h3>
    <p><b>Poda de Primer Orden</b> - Eliminación de datos de transacciones de bloques antiguos mientras se mantiene un conjunto UTXO para la validación.</p>
    <p><b>Conjunto UTXO del Punto de Poda</b> - Una instantánea de todas las salidas gastables en el punto de poda, utilizada como base para la validación.</p>
    <p><b>Estado de "Solo Encabezado"</b> - Bloques cuyos datos de transacción han sido podados pero conservan sus encabezados.</p>
    <p><b>Avance UTXO</b> - El proceso de actualizar el conjunto UTXO del punto de poda a medida que avanza el punto de poda.</p>
    <p>La poda de primer orden permite la eficiencia de almacenamiento mientras preserva las capacidades de validación a través de los conjuntos UTXO.</p>
  </div>

  <h3 class="section-title">Bitcoin vs. Kaspa: Arranque de Nodo Completo</h3>
  <p><b>Bitcoin</b> - Los nodos completos deben descargar y validar todos los datos de los bloques desde el génesis para arrancar, lo que requiere datos históricos completos de las transacciones. Si bien Bitcoin admite una poda simple después de la sincronización inicial, los nuevos nodos aún necesitan el historial completo de la cadena de bloques para establecer el estado inicial. La estructura de cadena lineal hace que este proceso sea sencillo pero intensivo en almacenamiento.</p>
  <p><b>Kaspa</b> - Los nodos completos pueden arrancar utilizando pruebas de poda sin descargar datos históricos completos, gracias a la integración de la poda de primer orden con el protocolo de consenso. El sistema valida las pruebas de poda y aplica datos criptográficamente verificables ("datos confiables") para establecer el estado inicial. Estos "datos confiables" no requieren confianza en ninguna parte; se verifican matemáticamente mediante pruebas criptográficas que garantizan que los datos cumplen con las reglas de consenso. El proceso de validación prueba criptográficamente que la prueba del punto de poda representa un estado de consenso válido, mientras que los datos confiables se someten a una verificación rigurosa para garantizar que coinciden con el estado esperado de la cadena de bloques. Esto permite que los nuevos nodos se sincronicen de manera eficiente mientras mantienen capacidades de validación completas sin confiar en una parte externa.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.juf0jn9hl1ev">Capítulo 11: Nodos de Archivo vs. Nodos Completos</h2>
  <div class="img-container"><img alt="Nodos de Archivo vs. Nodos Completos" src="images/image76.png"></div>
  <h3 class="section-title" id="h.knim47a94vo6">Nodos de Archivo de Kaspa vs. Nodos de Poda</h3>
  <p><b>Los Nodos de Poda Son Nodos Completos</b> - Los nodos de poda que utilizan la poda de primer orden y la poda de segundo orden todavía se consideran Nodos Completos porque mantienen capacidades de validación completas. Pueden validar todos los nuevos bloques, participar en el consenso y servir a la red sin requerir confianza en partes externas. El sistema de prueba de puntos de poda garantiza que, incluso con datos podados, estos nodos mantengan la verificación criptográfica del estado completo de la cadena de bloques.</p>
  <p><b>Los Nodos de Archivo Son Opcionales</b> - Los nodos de archivo que retienen todos los datos históricos no son necesarios para que la red Kaspa funcione indefinidamente. La red puede operar completamente con nodos de poda porque las pruebas de puntos de poda proporcionan garantías matemáticamente verificables sobre el estado podado. Esto contrasta con Bitcoin, donde la red requiere Nodos de Archivo (que almacenan el historial completo de transacciones desde el génesis) para arrancar un nuevo nodo.</p>
  <p><b>Sin Requisito de Confianza Adicional</b> - El sistema de poda mantiene el modelo sin confianza de Bitcoin utilizando pruebas criptográficas en lugar de partes confiables. Los nuevos nodos pueden arrancar a partir de pruebas de poda y verificar el estado completo de la cadena de bloques sin descargar todos los datos históricos, manteniendo las mismas garantías de seguridad que los nodos que almacenan todo desde Génesis.</p>
  <p><b>Sostenibilidad de la Red</b> - Este diseño garantiza que la red Kaspa pueda escalar de forma sostenible sin requerir un almacenamiento cada vez mayor por parte de los participantes. Los nodos de poda ofrecen la misma seguridad de consenso que los nodos de archivo, al tiempo que permiten una participación más amplia en la red a través de requisitos de hardware reducidos.</p>
  <p><b>Comportamiento del Nodo de Archivo</b> - Los nodos configurados como archivo ignoran por completo la poda de primer orden y la poda de segundo orden, preservando todos los datos de consenso (y los datos de aplicaciones históricas). Estos nodos sirven como un libro de contabilidad de consenso completo de la red, pero requieren el máximo almacenamiento y son puramente opcionales para el funcionamiento de la red.</p>
  <p><b>Eficiencia del Nodo de Poda</b> - Los nodos de poda regulares (Nodos Completos) utilizan la poda para lograr la máxima eficiencia de almacenamiento mientras mantienen capacidades de validación de consenso completas a través del sistema de prueba multinivel. Estos nodos son indistinguibles de los nodos de archivo en términos de seguridad y capacidades de validación.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.xoj5wjv6tg4b">Capítulo 12: Kaspa: Una Evolución en la Arquitectura Descentralizada Eficiente en Energía</h2>
  <h3 class="section-title" id="h.pfav0qmvzt92">Introducción: La Física del Dinero y la Eficiencia</h3>
  <p>En el mundo de las redes descentralizadas, la eficiencia no es solo un lujo, es un rasgo de supervivencia. Las criptomonedas funcionan como sistemas de energía monetaria, donde la energía del mundo real se convierte en registros de valor seguros e inmutables. Así como los sistemas físicos se esfuerzan por minimizar la energía desperdiciada y la entropía, una red criptográfica bien diseñada debe minimizar el desperdicio y la fricción. Bitcoin fue pionero en este concepto al vincular el valor monetario con el gasto de energía de la prueba de trabajo, creando una forma de "oro digital" asegurada por el costo termodinámico. Pero la arquitectura de Bitcoin, aunque revolucionaria, tiene ineficiencias estructurales que limitan su rendimiento y desperdician parte de la energía que los mineros invierten en ella.</p>
  <p>Entra Kaspa, una red de prueba de trabajo de próxima generación que redefine la arquitectura del consenso descentralizado. Kaspa se basa en un blockDAG (Grafo Dirigido Acíclico) en lugar de una sola cadena, lo que permite crear y procesar múltiples bloques en paralelo. Este diseño tiene como objetivo minimizar la entropía y la ineficiencia del sistema, haciendo de Kaspa una especie de "motor eficiente" para almacenar y mover valor económico.</p>

  <h3 class="section-title">Entropía, Energía y Sistemas Monetarios</h3>
  <p>Para comprender la importancia de Kaspa, primero debemos entender cómo la energía y la entropía se relacionan con los sistemas monetarios. En física, crear orden (baja entropía) en un lugar requiere gastar energía y aumentar la entropía en otro, un principio que también se aplica al dinero. El dinero fuerte como el oro históricamente derivó su valor de la inmensa energía y el trabajo necesarios para obtenerlo. Bitcoin aplicó este mismo principio digitalmente, requiriendo que los mineros realizaran cálculos costosos (hashing) para agregar bloques, asegurando así que cada moneda y bloque contengan prueba de energía gastada. Sin embargo, si una parte significativa del trabajo se desperdicia o si el diseño del sistema causa fricción innecesaria, entonces el "motor monetario" pierde energía en forma de calor.</p>

  <h3 class="section-title">Fricción en los Sistemas Económicos</h3>
  <p>En economía, la fricción se refiere a cualquier cosa que cause pérdida o ineficiencia en el movimiento de valor. Bitcoin introdujo algo de fricción por necesidad: su diseño sacrifica velocidad por seguridad. Las transacciones esperan unos 10 minutos en promedio para un nuevo bloque, y la convención es esperar 6 confirmaciones (aproximadamente 1 hora) para una alta seguridad contra la reversión. Esta latencia y bajo rendimiento crean fricción económica. Además, el proceso de minería de Bitcoin a veces produce trabajo desperdiciado en forma de bloques huérfanos (cuando dos mineros encuentran un bloque válido casi al mismo tiempo, solo un bloque se convierte en parte de la cadena principal y el otro se descarta). Estos bloques huérfanos representan energía real gastada por los mineros que no contribuye de manera sostenible al libro mayor.</p>

  <h3 class="section-title">El Cuello de Botella de Cadena Única de Bitcoin</h3>
  <p>La cadena de bloques de Bitcoin puede visualizarse como una carretera de un solo carril para las transacciones. Solo se puede aceptar un bloque a la vez, y cada bloque debe alinearse secuencialmente. Si dos bloques llegan al mismo tiempo, uno se verá obligado a ceder y será efectivamente descartado como huérfano. Este diseño se eligió deliberadamente para mantener el sistema en orden, pero a costa de severas limitaciones de rendimiento. Las limitaciones de esta arquitectura de cadena única son bien conocidas: falta de escalabilidad, susceptibilidad a ataques de minería egoísta si se redujeran los tiempos de bloque, y bloques desperdiciados son problemas inherentes. Fundamentalmente, el consenso de Bitcoin desperdicia una pequeña pero no despreciable porción del trabajo de minería en bloques que nunca forman parte del libro mayor. Estos bloques huérfanos son la entropía del sistema: energía que aumentó el desorden y se disipó como calor, no se almacenó como información útil. El resultado es que la enorme energía de minería de Bitcoin produce solo un goteo de rendimiento.</p>

  <h3 class="section-title" id="h.y2juit6511i3">BlockDAG de Kaspa: Paralelismo sin Trabajo Desperdiciado</h3>
  <p>Kaspa abordó el problema preguntando: ¿y si los bloques no tuvieran que alinearse en fila india? En lugar de una carretera de un solo carril, Kaspa utiliza una autopista de varios carriles para bloques, donde se pueden crear muchos bloques en paralelo y aun así fusionarse en un único libro mayor. La innovación fundamental es la arquitectura blockDAG (Grafo Dirigido Acíclico) de Kaspa combinada con el protocolo de consenso GHOSTDAG. En un blockDAG, los bloques no apuntan a un solo bloque anterior (la punta de la "cadena más larga") como en Bitcoin; en cambio, cada bloque puede referenciar múltiples predecesores, incluidas diferentes "puntas" del grafo. Los bloques que se considerarían en competencia o huérfanos en Bitcoin no se descartan en Kaspa, se incorporan al grafo del libro mayor. La estructura DAG permite que estos bloques simultáneos coexistan y finalmente sean ordenados consistentemente por el algoritmo GhostDAG. Todos los bloques válidos contribuyen al historial del libro mayor; el trabajo de prueba de ningún minero se desperdicia.</p>
  <p>El impacto de este diseño en la eficiencia es espectacular. Primero, no se desperdicia poder de minería en bloques huérfanos. Segundo, el paralelismo de Kaspa aumenta significativamente el rendimiento. Kaspa opera a una tasa base de 1 bloque por segundo en su red principal (y recientemente se ha actualizado a 10 bloques por segundo), en comparación con 0.1 bloques por segundo para Bitcoin. Esto es un aumento de 10 veces en la frecuencia de bloques por diseño, con planes para aún más. Además, debido a que cada bloque de Kaspa es más pequeño (para mantener bajos los requisitos de los nodos) pero llegan con mucha más frecuencia, las transacciones se distribuyen en muchos bloques. El resultado final es un rendimiento potencial de miles de transacciones por segundo. De hecho, el algoritmo GhostDAG ha demostrado que puede soportar aproximadamente 3000 transacciones por segundo con 10 bloques/segundo en redes de prueba utilizando hardware común. Esto se ha logrado manteniendo requisitos de hardware modestos. En otras palabras, la arquitectura de Kaspa no obliga a un compromiso entre escalabilidad y descentralización; procesa muchas más transacciones sin aumentar la barrera de entrada para los nodos. Cada participante aún puede validar la cadena en computadoras comunes, lo cual es crucial para la descentralización. A diferencia de muchos sistemas de alto rendimiento que dependen de nodos de centros de datos potentes o comprometen el consenso, Kaspa sigue siendo un sistema puro de prueba de trabajo con una amplia distribución de minería y nodos completos.</p>
  <p>¿Cómo mantiene Kaspa un historial único y acordado (una única fuente de verdad) si los bloques llegan en paralelo? La respuesta es GhostDAG, un algoritmo de consenso que ordena los bloques en el DAG considerando no solo la "cadena más larga" (como en Bitcoin) sino el "subgrafo más pesado" de bloques. GhostDAG asigna a cada bloque una especie de puntuación u ordenación basada en la cantidad de historial validado que lo precede y cómo referencia a otros bloques. Encuentra un patrón llamado k-clúster, esencialmente un conjunto de bloques mutuamente conscientes, y lo utiliza para decidir qué bloques forman parte de la estructura ordenada principal (coloreados "azules") y cuáles están fuera de la estructura principal ("rojos") pero aún incluidos. El algoritmo es codicioso pero converge de manera demostrable a un historial único similar al consenso de Nakamoto, excepto que puede hacerlo incluso cuando muchos bloques están en progreso. La garantía formal es que a medida que se acumulan los bloques, la probabilidad de que el orden de un bloque dado cambie (es decir, una reversión de bifurcación) disminuye exponencialmente, al igual que con las confirmaciones de Bitcoin, pero esta seguridad se logra a tasas de bloque mucho más altas. En términos prácticos, las transacciones de Kaspa se entierran profundamente bajo muchos bloques mucho más rápido que en Bitcoin, lo que las hace muy seguras contra reorganizaciones en segundos. El equipo de Kaspa señala que el ordenamiento de GhostDAG "se vuelve exponencialmente más difícil de revertir a medida que pasa el tiempo", incluso a altas tasas de creación de bloques. La finalidad es rápida; la red logra lo que podría llamarse una irreversibilidad termodinámica de las transacciones a escala humana.</p>
  <p>Dado que todos los bloques se conservan, los mineros de Kaspa no tienen incentivos para retener o minar egoístamente de forma estratégica para dejar huérfanos los bloques de otros, un comportamiento que puede ser racional en contextos de blockchain más rápidos. La estrategia de Kaspa de máxima revelación de información (cada bloque referencia todas las puntas que conoce) significa que la red se informa rápidamente de todos los bloques paralelos. Esto inunda el grafo de conocimiento, reduciendo la incertidumbre. En términos de teoría de la información, Kaspa minimiza la entropía del estado de la red al garantizar que no persistan bifurcaciones invisibles durante mucho tiempo; todo se integra. El "principio de máxima revelación" esencialmente tiene como objetivo reducir la entropía del sistema (incertidumbre) al compartir datos lo más eficientemente posible. Esto, de nuevo, se alinea con los principios físicos: para mantener el orden, se desea propagar la información (o señales energéticas) de la manera más eficiente posible a través del sistema.</p>
  <p>Es importante señalar que Kaspa logra esto sin comprometer la seguridad ni la descentralización. Todavía utiliza la prueba de trabajo, lo que significa que la validez de cada bloque está garantizada por la energía real gastada. Y debido a que los bloques son más pequeños y frecuentes, el ancho de banda y el almacenamiento de los nodos se han gestionado cuidadosamente (con técnicas como la poda y la gestión eficiente de UTXO) para que incluso una computadora doméstica pueda mantenerse al día. El resultado es una red que ofrece "seguridad y descentralización de grado de prueba de trabajo con un rendimiento comparable al de las principales redes de prueba de participación". A diferencia de algunos proyectos que han resuelto el problema de la escalabilidad abandonando la PoW o centralizando la producción de bloques, Kaspa conserva la seguridad física de la prueba de trabajo del consenso de Nakamoto. No hay dependencia de validadores privilegiados o puntos de control de comité; siguen siendo mineros compitiendo con hashes, pero ahora, el bloque de cada minero encuentra su lugar en la historia, y el rendimiento de la red ya no se ve estrangulado por el participante más lento.</p>
  <p>En pocas palabras, el protocolo GhostDAG de Kaspa elimina el cuello de botella estructural que Bitcoin había considerado inevitable. El antiguo trilema de "seguridad vs. velocidad vs. descentralización" está, según Kaspa, completamente resuelto en la práctica. Al apartarse del modelo de cadena lineal, Kaspa abre las compuertas del rendimiento sin sacrificar la seguridad de Nakamoto, una hazaña que muchos investigadores consideraron imposible durante años. Todo esto lleva a un sistema donde los bloques llegan continuamente como gotas en una fuente bien sincronizada, en lugar de los bloques puntuales e intermitentes del reloj de Bitcoin. Las transacciones en Kaspa se confirman en segundos y se finalizan (con una probabilidad de reorganización insignificante) típicamente en unas pocas decenas de segundos. De hecho, el objetivo de diseño de Kaspa era que los tiempos de confirmación solo estuvieran limitados por la latencia de la red, tan rápido como la información pueda viajar físicamente por Internet. La red ya entrega transacciones completamente confirmadas en unos 10 segundos en promedio, y este número disminuye a medida que aumentan las tasas de bloques. Desde la perspectiva del usuario, esto significa que enviar valor a través de Kaspa se siente casi como un pago con tarjeta de crédito o una transferencia en efectivo: la liquidación es casi instantánea, pero con el beneficio adicional de que es irreversible y sin confianza.</p>

  <h3 class="section-title" id="h.ttddfh4xlbpu">Logrando un Rendimiento a la Velocidad de la Luz</h3>
  <p>Una forma de apreciar la alineación de Kaspa con los principios físicos es examinar su manejo de la latencia, el retraso de un lado del mundo al otro. El tiempo de ida y vuelta (RTT) de Internet global, esencialmente el tiempo que tarda una señal en ir a las antípodas y regresar, es del orden de 200 milisegundos (0,2 segundos) en el mejor de los casos (limitado por la velocidad de la luz en la fibra y los saltos de red). Las cadenas de bloques tradicionales como Bitcoin operan órdenes de magnitud más lentas que este límite (600 segundos por bloque), por lo que la latencia de la red no es un factor importante en su diseño; viven en un régimen de equilibrio lento y cómodo. Pero Kaspa se ha aventurado audazmente en el régimen donde los tiempos de bloque son del orden de la latencia de la red, actualmente 100 milisegundos por bloque en la nueva actualización (10 BPS), lo que en realidad es más rápido que la propagación unidireccional al otro lado de la Tierra. Este es un umbral crítico. Pasar de un tiempo de bloque de 1 segundo a uno de 0,1 segundos no es solo una mejora cuantitativa de 10 veces; es un salto cualitativo que requirió repensar el consenso.</p>
  <p>¿Por qué? Si intentara ejecutar un consenso de cadena única (lineal) con bloques de 100 ms en una red global, tendría un caos total: apenas un nodo ha oído hablar de un bloque cuando ya se han encontrado otros cinco. El retraso de propagación significaría que la red nunca está sincronizada; las bifurcaciones proliferarían y el consenso se rompería o se centralizaría (solo las conexiones más rápidas siempre ganarían). Kaspa es el primer sistema de prueba de trabajo en demostrar consenso en este régimen sub-RTT, y puede hacerlo precisamente porque su GhostDAG multilíder puede manejar muchos bloques simultáneos de manera elegante. Como señaló el desarrollador principal Michael Sutton durante la actualización Crescendo de Kaspa (que movió la red principal de 1 BPS a 10 BPS), "Aumentar la tasa de bloques a 10 por segundo, logrado al reducir el tiempo de bloque a 100 ms (< 200 ms ≊ RTT global), solo puede asegurarse con un protocolo de consenso que permita inherentemente el paralelismo... Cruzar el umbral RTT es, por lo tanto, un salto cualitativo, no solo cuantitativo". En otras palabras, el diseño de Kaspa está fundamentalmente alineado con los límites físicos de la transferencia de información: está estructurado para operar a la velocidad máxima que permiten las leyes de la física (velocidad de la luz, ancho de banda de la red), mientras que una cadena lineal no puede cruzar este límite de forma segura sin sacrificar la seguridad o asumir un radio de red más pequeño.</p>
  <p>Vale la pena enfatizar lo notable que es esto en el contexto de los sistemas distribuidos. Kaspa logra un consenso global asíncrono con tiempos de bloque más cortos que los retrasos de comunicación global. Y lo hace sin reducir la red ni requerir una configuración de confianza especial. La red sigue siendo vasta y sin permisos (los nodos pueden estar en cualquier parte del mundo, conectados por enlaces de Internet estándar), y, sin embargo, Kaspa produce y confirma bloques más rápido de lo que cualquier cadena única podría imaginar en estas condiciones. El protocolo GhostDAG esencialmente permite lo que la teoría del consenso clásico habría creído imposible bajo una estricta regla de cadena más larga: mantener a todos de acuerdo a pesar de las constantes mini-bifurcaciones (bloques paralelos). La idea es que al permitir que estas bifurcaciones existan y luego ordenarlas probabilísticamente, se abraza el caos y se organiza, en lugar de intentar evitarlo por completo. El resultado es un rendimiento máximo.</p>
  <p>Tras la activación de la bifurcación dura Crescendo, los desarrolladores de Kaspa señalaron que el sistema fue diseñado de tal manera que incluso a 10 BPS, no se necesitaba una supercomputadora para ejecutar un nodo. La implementación en Rust y las optimizaciones del protocolo garantizan que una PC promedio con una conexión a Internet doméstica pueda mantenerse al día con 10 bloques por segundo y miles de transacciones por segundo. Esto demuestra una ética de diseño centrada en la eficiencia en todos los niveles, no solo en el rendimiento bruto, sino también en el uso eficiente de los recursos informáticos y el ancho de banda. Por ejemplo, los bloques permanecen compactos, y la estructura DAG se poda y gestiona para que no se vuelva inmanejable. Kaspa incluso incluye nuevas técnicas (como el próximo DAGKnight y las estrategias de poda) para adaptarse a las condiciones de la red y limitar el tamaño del estado. Todas estas elecciones reflejan un minimalismo casi físico: eliminar el desperdicio, ya sea poder de hashing desperdiciado, tiempo desperdiciado o almacenamiento desperdiciado. Si la minería de Bitcoin a veces es criticada por producir mucho calor (energía desperdiciada por transacción), Kaspa reduce significativamente la energía por transacción al aumentar el rendimiento y utilizar un algoritmo de hashing más eficiente energéticamente (kHeavyHash). El equipo de Kaspa diseñó explícitamente kHeavyHash para que fuera compatible con la minería óptica y de recursos ligeros, lo que significa que podría ejecutarse potencialmente en hardware especializado que consume mucha menos electricidad. Combinado con la política de "no bloques desperdiciados" del DAG, esto hace que Kaspa sea menos intensiva en energía que otras redes PoW por transacción o por valor transferido. En pocas palabras, Kaspa puede hacer más con cada julio de energía que los mineros invierten en ella, un testimonio de su ingeniería superior. Incluso observadores independientes señalan esta eficiencia: "El algoritmo KHeavyHash está diseñado para optimizar el consumo de energía, haciendo que [Kaspa] sea menos intensiva en recursos en comparación con... Bitcoin". Podemos ver esto como una mejora en la eficiencia termodinámica del sistema: una mayor parte de la energía de entrada se convierte en transacciones seguras y finalizadas (trabajo útil) en lugar de un hashing desperdiciado o tiempo de espera.</p>
  <p>Al empujar los límites físicos de manera responsable, Kaspa se posiciona como una red monetaria altamente eficiente termodinámicamente. Alinea la cadencia de producción de bloques con la comunicación más rápida posible, elimina el trabajo redundante y asegura que cada bit de trabajo contribuya al ordenamiento de las transacciones. Por analogía, si Bitcoin es como un viejo motor térmico que produce mucho calor residual y funciona a baja velocidad, Kaspa es como una turbina moderna que opera cerca de su límite de eficiencia teórico, extrayendo el movimiento más útil (rendimiento de transacciones) posible de cada unidad de combustible (energía de hashing). Las leyes de la física establecen un límite estricto, y Kaspa está decidida a alcanzar ese límite. Esta alineación con los "flujos direccionales" de la evolución tecnológica (más producción con menos insumos) sugiere que Kaspa sigue una trayectoria evolutiva que hemos observado en muchos otros sistemas: de procesadores de un solo núcleo a multinúcleo y procesamiento paralelo, de acceso telefónico a Internet de banda ancha, de carruajes tirados por caballos a autopistas de varios carriles. Los sistemas que aprovechan el paralelismo y reducen la resistencia interna inevitablemente superan a los que permanecen atascados en un solo proceso secuencial.</p>

  <h3 class="section-title" id="h.uttpgy92hgk">Menos Fricción, Mejor Retención de Valor</h3>
  <p>Las virtudes técnicas del diseño de Kaspa tienen profundas implicaciones económicas. Cuando reducimos la entropía y la fricción en un sistema monetario, creamos un entorno más hospitalario para que el valor resida y circule. Considere una economía como un ecosistema vivo o quizás una red eléctrica: si la energía (o el dinero) puede fluir libremente donde se necesita con pérdidas mínimas, el sistema prospera y crece. La red de baja latencia y alto rendimiento de Kaspa significa que el valor puede intercambiarse de forma rápida y económica por cualquier persona, en cualquier lugar, sin ser desviado por intermediarios o altos costos de espera. Esta propiedad atrae naturalmente el uso: los usuarios preferirán un sistema donde sus pagos se confirmen en un segundo a uno donde esperan una hora, especialmente cuando la seguridad es comparable. A medida que aumenta el uso, la liquidez y el capital gravitan hacia la red, aumentando su utilidad en un ciclo de retroalimentación. La economía básica nos dice que, dadas dos opciones, las personas elegirán la que tenga los costos de transacción más bajos (todo lo demás igual), y el dinero fluirá a través del canal que ofrezca la menor impedancia al comercio. Kaspa se presenta como este canal de baja impedancia: "mínimo trabajo disipado, mínima impedancia transaccional, máxima claridad monetaria", como describió un observador el punto de convergencia donde fluirá el capital. Con Kaspa, las barreras tradicionales (retrasos de confirmación, límites de rendimiento, tarifas altas durante la congestión) se minimizan significativamente, por lo que el "tubo" para la energía monetaria es ancho y suave.</p>
  <p>Plan K, en una entrevista sobre la economía de Kaspa, utilizó una analogía biológica para describir cómo el dinero eficiente dirige la energía: el buen dinero es como el sistema vascular de una planta que canaliza los nutrientes (energía) hacia las hojas fotosintéticas (trabajo productivo), en lugar de permitir que los recursos sean absorbidos por parásitos o partes inactivas. En esta analogía, Kaspa puede verse como una forma de dinero de baja entropía que fomenta un flujo eficiente de energía. Su velocidad y capacidad aseguran que la energía económica (valor) se mueva hacia usos productivos (transferencias reales de bienes y servicios) en lugar de desperdiciarse en atrasos o arbitraje entre capas. Mientras tanto, su base de prueba de trabajo evita la desviación de energía que ocurre con el "dinero fácil". Las monedas fiduciarias, por ejemplo, se han comparado con una enredadera parasitaria en la analogía de Plan K: pueden ser infladas o copiadas por las autoridades centrales, desviando efectivamente energía de la economía productiva al diluir el valor. Kaspa, al igual que Bitcoin, se inmuniza contra tal dilución al requerir trabajo real para la creación de nuevas monedas y al limitar estrictamente el crecimiento de la oferta. Como señaló Plan K, "El oro, Bitcoin y Kaspa son similares a [hormonas] que no se pueden copiar, lo que evita cualquier desviación de energía". En términos más simples, estas monedas fuertes bloquean la energía que se utilizó para producirlas; ofrecen una reserva segura para el valor económico sin fugas por devaluación.</p>
  <p>Kaspa extiende este principio de dinero fuerte al ámbito de la usabilidad diaria. Bitcoin demostró que una red descentralizada puede almacenar valor de forma segura (baja entropía con el tiempo), pero Kaspa también tiene como objetivo mover valor de forma eficiente (baja entropía en las transacciones). Al casar el costo inquebrantable de Bitcoin con una capa transaccional sin fricciones, Kaspa se posiciona como una solución completa para el dinero: una reserva de valor, un medio de intercambio y una unidad de cuenta, todo en uno, sin los compromisos habituales. Es instructivo recordar por qué históricamente el oro necesitaba un sustituto (como el papel moneda o la moneda fiduciaria) para las transacciones diarias, porque el oro era pesado y lento de mover, lo que introducía fricción. Bitcoin, al ser lento y con un rendimiento limitado, ha invitado de manera similar a las redes de Capa 2 o a las monedas en competencia a llenar el vacío para pagos rápidos, cediendo esencialmente el papel de medio de intercambio a monedas "más blandas". Kaspa, por otro lado, es lo suficientemente rápido y escalable como para no requerir una red monetaria secundaria para manejar el volumen. Puede ser tanto la capa de liquidación de alta integridad como la capa de transacción de alta velocidad. Esto sugiere un futuro en el que la actividad económica no necesitará cambiar constantemente entre una "red de reserva de valor" y una "red de pago" (con toda la fricción de intercambio y los compromisos de seguridad que eso implica); en cambio, una sola red puede hacerlo todo de manera eficiente. De hecho, los defensores argumentan que, dado que Kaspa ha resuelto el trilema, "ya no hay una brecha en el mercado monetario que Kaspa no llene", eliminando la necesidad de reservas base más lentas como Bitcoin o alternativas más rápidas pero más débiles. Si Bitcoin sigue siendo una capa de liquidación de alto valor y Kaspa más para el intercambio, o si Kaspa eventualmente absorbe ambos roles, el mercado lo decidirá. Pero una cosa está clara: los sistemas que desperdician menos y ofrecen más ganarán a la larga a los que no lo hacen. Esta es la selección natural aplicada a los sistemas monetarios.</p>
  <p>Menos fricción también significa que los mineros y los usuarios están mejor alineados en el ecosistema Kaspa. En Bitcoin, los usuarios a veces se quejan de pagar tarifas altas durante la congestión (que en última instancia van a los mineros), y los mineros lidian con la varianza y las pérdidas debido a los huérfanos. En Kaspa, el alto rendimiento mantiene las tarifas bajas (porque la capacidad es abundante), y el diseño sin huérfanos significa que los mineros no pierden recompensas debido a la latencia de la red. Los mineros aún obtienen su justa recompensa; de hecho, la recompensa de bloque de Kaspa se distribuye en muchos más bloques por unidad de tiempo, lo que, paradójicamente, hace que el proceso de minería sea más granular y justo (múltiples mineros por segundo pueden obtener recompensas, en lugar de un solo ganador cada 10 minutos). Esto puede reducir la varianza de la minería y las presiones centralizadoras (porque en Bitcoin, un pool de minería que encuentra un bloque ligeramente más rápido gana una recompensa del 100% durante 10 minutos, mientras que en Kaspa, muchos mineros obtienen una recompensa menor cada segundo, un sistema "multilíder" donde la ventaja se promedia). Más mineros pueden incluir bloques casi simultáneamente, lo que podría reducir la tendencia monopolística de un minero que domina un segmento de tiempo dado. La "mayor competencia dentro de cada ronda de latencia" incluso tiene implicaciones para reducir el MEV (valor extraíble por el minero) y la manipulación, porque cuando los bloques son paralelos, es mucho más difícil para un solo actor controlar el orden de las transacciones. De hecho, el paralelismo de Kaspa añade un poco de caos que promueve la equidad: se vuelve imposible aplicar ciertas explotaciones que requieren un control estricto sobre el orden, lo que reduce la entropía de los resultados del mercado (los precios de mercado y las transacciones reflejan la verdadera oferta y demanda, no la interferencia del minero). Este es otro ejemplo de cómo el enfoque de Kaspa tiende a preservar el valor dentro del sistema, al hacer que el comportamiento del sistema sea termodinámicamente más irreversible, en el sentido de que ningún actor puede revertir o reordenar transacciones fácilmente para su beneficio, los cambios de estado de la red (transacciones ejecutadas) son auténticos y duraderos. Alinea los flujos económicos con una inevitabilidad casi física: una vez que algo sucede en Kaspa, esencialmente está hecho y no se puede deshacer o engañar fácilmente.</p>
  <p>Desde una perspectiva macro, si se considera la competencia global de monedas y redes como un panorama evolutivo, un sistema como Kaspa que ofrece baja resistencia y alta integridad tenderá a acumular "masa monetaria". Con el tiempo, la liquidez genera liquidez: los usuarios van donde están otros usuarios y comerciantes. Si Kaspa continúa ofreciendo una seguridad similar a la de Bitcoin con un rendimiento significativamente mejor, es razonable pensar que más actividad económica se trasladará a Kaspa. Ya hemos visto históricamente que las monedas fiduciarias reemplazaron al oro para las transacciones debido a su menor fricción, aunque el oro es una reserva de valor superior; y ahora las criptomonedas desafían a la moneda fiduciaria combinando la dureza con la velocidad digital. Kaspa puede verse como el siguiente paso: combinar la dureza definitiva del dinero PoW con la velocidad definitiva de las redes modernas. En el lenguaje de la física, Kaspa podría ser el "punto final gravitacional" para la energía monetaria: un atractivo masivo que atrae capital porque representa un estado de energía potencial mínima (es decir, no se puede encontrar fácilmente un sistema donde su dinero sea más seguro y más fácil de usar al mismo tiempo). Cuando no hay un camino más fácil (estado de energía más bajo) para que fluya el valor, se ha alcanzado el equilibrio, y Kaspa aspira a ser ese punto de equilibrio para el dinero descentralizado.</p>

  <h3 class="section-title">Irreversibilidad y la Flecha del Tiempo en Kaspa vs. Bitcoin</h3>
  <p>Un aspecto sorprendente de los sistemas de prueba de trabajo es cómo establecen una flecha del tiempo. Cada bloque es un evento irreversible; una vez que se realiza el trabajo y se acepta el bloque, deshacerlo requeriría gastar una cantidad equivalente (o mayor) de energía. Esta función unidireccional del trabajo le da a las cadenas de bloques una dirección temporal: al igual que la entropía en física, es fácil avanzar (minar nuevos bloques, aumentar la entropía) pero extremadamente difícil retroceder (deshacer bloques, disminuir la entropía) sin intervención externa. La cadena de bloques de Bitcoin, asegurada por la energía, a menudo se compara con la flecha del tiempo: una secuencia de historia cada vez más "establecida". Kaspa hereda esta propiedad pero la acelera. Debido a que los bloques llegan tan rápidamente y GhostDAG profundiza rápidamente el historial del libro mayor, la irreversibilidad de las transacciones se agrava más rápido en Kaspa que en Bitcoin. La probabilidad de revertir una transacción en Kaspa disminuye exponencialmente con cada segundo que pasa, ya que múltiples bloques nuevos consolidan el orden. En Bitcoin, seis bloques (aproximadamente una hora) se referencian típicamente para una alta confianza; en Kaspa, un nivel similar de seguridad podría lograrse en quizás una docena de bloques, lo que a 1 bloque/segundo era aproximadamente 12 segundos (y a 10 bloques/segundo, es poco más de un segundo, aunque entran en juego otros factores de latencia).</p>
  <p>Esto significa que la finalidad del libro mayor de Kaspa se acerca a algo muy parecido a la irreversibilidad en tiempo real. El comportamiento del sistema refleja un proceso termodinámico irreversible que muy rápidamente alcanza un punto sin retorno. Por ejemplo, si se emiten dos transacciones conflictivas (intentos de doble gasto), la rápida inclusión y ordenación de bloques de Kaspa decidirá al ganador y acumulará confirmaciones sobre él en segundos, haciendo que el intento del perdedor de revertir sea cada vez más inútil. En Bitcoin, este período de incertidumbre (entropía) podría durar muchos minutos e incluso entonces puede ser explotado por un atacante con suficiente poder de hashing en un estado de baja entropía (antes de que se acumulen muchas confirmaciones). Kaspa reduce esta ventana, haciendo que el costo de revertir el historial sea extremadamente alto casi de inmediato. Podemos ver esto como Kaspa aumentando el gradiente termodinámico que un atacante debe escalar, una colina más empinada que se vuelve más empinada más rápido. Esto, de nuevo, está relacionado con la eficiencia: la red no pierde el tiempo convirtiendo el poder de hashing en seguridad (orden), por lo que un atacante no tiene el "lujo" de una larga ventana de vulnerabilidad para explotar. La entropía de la incertidumbre se expulsa rápidamente del sistema, dejando un estado muy ordenado (transacciones confirmadas) que es estable.</p>
  <p>Otra perspectiva es la del principio de Landauer, un concepto en física que establece que borrar un bit de información tiene un costo energético irreducible (disipación de calor). En las cadenas de bloques, "borrar" una transacción (mediante una reorganización que elimina una transacción confirmada del historial) es extremadamente costoso en energía, razón por la cual las grandes reorganizaciones son inviables si los mineros honestos controlan la mayoría del poder de hashing. Kaspa garantiza que los bits de datos de las transacciones se incorporen a muchos bloques (bits de información) casi de inmediato, por lo que la información echa raíces y se vuelve termodinámicamente costosa de borrar. Esencialmente, Kaspa alinea la teoría de la información con la termodinámica: la información (el estado del libro mayor) adquiere una permanencia resistente a la entropía rápidamente, arraigada por la prueba de trabajo. Y debido a que Kaspa utiliza su energía de entrada de manera más eficiente (sin bloques desperdiciados, más confirmaciones por unidad de tiempo), podría decirse que logra una mayor "irreversibilidad por unidad de energía" que Bitcoin. Cada julio de minería en Kaspa contribuye a la finalidad de muchas transacciones, mientras que en Bitcoin, cada julio asegura menos transacciones (y algunos julios se gastan en bloques que quizás ni siquiera cuenten).</p>
  <p>La metáfora de la flecha del tiempo es apropiada: la flecha de Bitcoin avanza lenta pero inexorablemente, tardando más en establecer firmemente la historia, mientras que la flecha de Kaspa vuela a gran velocidad, fijando rápidamente los eventos en el tiempo. Ambas flechas apuntan en la misma dirección, impuestas por la segunda ley de la termodinámica (consumo de energía), pero la de Kaspa cubre más distancia (profundidad del libro mayor) por unidad de tiempo. Esto no solo tiene ventajas prácticas (experiencia de usuario, rendimiento), sino que indica filosóficamente que el diseño de Kaspa está en armonía con la dirección "natural" de los sistemas complejos: hacia más orden logrado en menos tiempo mediante el gasto de energía. Si Bitcoin demostró que energía + tiempo = seguridad, Kaspa demuestra que con un mejor diseño, se puede lograr una seguridad equivalente con la misma energía en mucho menos tiempo, simplemente eliminando las ineficiencias internas. No viola ninguna ley fundamental; simplemente no desperdicia las oportunidades que Bitcoin deja sobre la mesa.</p>

  <h3 class="section-title">Conclusión: Kaspa como la Frontera Eficiente de las Redes Monetarias</h3>
  <p>Al examinar Kaspa a través de las lentes duales de la física y la economía, vemos surgir un tema: los sistemas evolucionan hacia una eficiencia óptima en el procesamiento de energía e información. En economía, el dinero ha evolucionado de bienes engorrosos a oro, a papel respaldado por oro, a redes digitales, cada paso con el objetivo de reducir la fricción mientras se preserva la confianza y el valor. En la informática y las redes, hemos pasado del procesamiento en serie al paralelo, de los retrasos analógicos a las señales casi a la velocidad de la luz. Kaspa representa la convergencia de estas trayectorias evolutivas en el ámbito del dinero descentralizado. Toma la dureza y la finalidad de la prueba de trabajo respaldada por energía, el aspecto que hace de Bitcoin una forma de "oro digital", y sobrecarga la eficiencia del sistema que utiliza esta energía. El resultado es una red que puede describirse como un motor de valor: convierte la energía eléctrica (trabajo de hashing) en valor económico digital (transacciones seguras y emisión de monedas) con un desperdicio mínimo, canalizando ese valor rápidamente donde debe ir.</p>
  <p>Al posicionar a Kaspa frente a Bitcoin, no se trata de rivalidad, sino de progreso en la arquitectura descentralizada. Bitcoin fue el prototipo que demostró que un enfoque termodinámico del dinero funcionaba. Kaspa es una evolución que refina la arquitectura para minimizar el desperdicio (entropía) y maximizar el rendimiento (trabajo útil) sin perder la esencia de lo que hizo grande a Bitcoin (descentralización y seguridad a través de la prueba de trabajo). Solo hemos comparado a Kaspa con Bitcoin porque ambos comparten la base fundamental de PoW y una política monetaria sólida, difiriendo principalmente en el diseño estructural. Y esa diferencia, un blockDAG frente a una blockchain, ha marcado la diferencia. El blockDAG de Kaspa es una solución natural a los cuellos de botella de Bitcoin, casi obvia en retrospectiva: si un carril es demasiado lento, agregue más carriles; si descartar bloques desperdicia energía, encuentre una manera de mantenerlos todos; si esperar la sincronización global causa latencia, permita cierta asincronía y luego resuélvala algorítmicamente. Estas son, en cierto sentido, optimizaciones de sentido común una vez que la tecnología permitió implementarlas. La brillante idea de GhostDAG fue encontrar una manera de hacer que muchos líderes (mineros) trabajaran juntos a la vez sin caos, como una sinfonía bien orquestada en lugar de una actuación en solitario. Esto demuestra que el orden puede surgir del caos aparente con las reglas correctas, haciendo eco de cómo los sistemas físicos se autoorganizan cuando se aplican las restricciones sabiamente.</p>
  <p>El resultado final de las elecciones de diseño de Kaspa es un sistema que, según algunos, constituye una culminación natural en el cálculo eficiente del valor. Es tan rápido como lo permite la física, tan seguro como puede ser la prueba de trabajo y tan descentralizado como debería ser una red globalmente inclusiva. ¿Podríamos ir más rápido o ser más eficientes sin romper el vínculo fundamental entre el dinero y la termodinámica? Probablemente no mucho, no sin una nueva física o comprometer la confianza. Kaspa ya aspira a 100 bloques por segundo en el futuro, acercándose a un flujo de bloques casi continuo, y sus desarrolladores están integrando características adaptativas (como DAGKnight) que ajustan la velocidad de confirmación a las condiciones. Nos estamos acercando a los límites prácticos de la escalabilidad en cadena en un contexto descentralizado. Cualquier ganancia significativa adicional probablemente requeriría enfoques fundamentalmente diferentes (o la aceptación de la centralización). En este sentido, Kaspa es la frontera eficiente: no se puede obtener un rendimiento significativamente mayor o una latencia menor a escala sin incurrir en más desperdicio o riesgo que Kaspa. Ha encontrado un equilibrio que utiliza los recursos de manera óptima.</p>
  <p>Para los profesionales e investigadores criptográficos experimentados, Kaspa ofrece un fascinante caso de estudio donde convergen los principios de la termodinámica, la teoría de la información y la economía. Valida la idea de que una red financiera descentralizada puede analizarse de la misma manera que un sistema físico, con entradas de energía, salidas de trabajo e ineficiencias como entropía. Al reducir estas ineficiencias, Kaspa no solo funciona mejor; fundamentalmente crea un sistema económico más sostenible y atractivo. Un sistema con menos desperdicio significa que el trabajo de los mineros rinde más, las tarifas de los usuarios se mantienen más bajas y circula más valor en lugar de quemarse en gastos generales. Con el tiempo, esto atrae más participación, más inversión y fortalece los efectos de red. Es análogo a cómo un motor eficiente no solo ahorra combustible, sino que permite nuevas capacidades (viajes más largos, cargas más pesadas), por lo que una cadena de bloques eficiente permite más actividad económica y casos de uso que ahogarían una cadena más lenta.</p>
  <p>En conclusión, Kaspa puede verse como la culminación de más de una década de investigación sobre cómo escalar la invención de Nakamoto sin perder su esencia. Demuestra que las leyes de la física y una economía sólida no son enemigas de la descentralización, sino guías para mejorarla. El éxito de Kaspa significaría que el sistema monetario que sigue más fielmente el camino de menor resistencia y menor producción de entropía prevalecerá, un resultado altamente alineado con la física. En términos prácticos, Kaspa representa una red de alto rendimiento, baja fricción y segura que podría transportar el valor de las naciones dentro de un solo protocolo, accesible para todos y limitado solo por la velocidad de la luz y la honestidad de la mayoría. Si Bitcoin abrió la puerta a una era financiera termodinámica, Kaspa se acelera hacia ella, haciendo que el flujo de energía económica sea tan eficiente como el flujo de electrones. En la gran narrativa de la tecnología y el dinero, Kaspa se destaca como una prueba convincente de que la eficiencia es el destino: dados dos sistemas, el que mejor minimice el desperdicio y maximice el trabajo útil atraerá el futuro. Y Kaspa presenta un argumento persuasivo y técnicamente sólido de que es ese sistema: un salto evolutivo hacia una red monetaria sin fricciones, que preserva el valor y, en última instancia, más alineada con el ser humano.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.e01avawvoirc">Capítulo 13: Kaspa vs. Ordenamiento de Bitcoin</h2>
  <div class="img-container"><img alt="Kaspa vs. Ordenamiento de Bitcoin" src="images/image33.png"></div>
  <h3 class="section-title">Selección y Ordenamiento de Bloques: Cadena Más Pesada vs. Trabajo Azul</h3>
  <h4 class="subsection-title">Regla de la Cadena Más Pesada de Bitcoin - Selección Secuencial</h4>
  <p>El mecanismo de consenso de Bitcoin opera bajo un principio lineal donde la red mantiene una única cadena de bloques. Cuando los mineros crean nuevos bloques simultáneamente, la red se enfrenta a una elección entre cadenas en competencia. La regla de la cadena más pesada resuelve esto seleccionando la cadena con la mayor prueba de trabajo acumulada, eligiendo así la ruta que representa la mayor inversión computacional. Este enfoque crea un escenario de "el ganador se lleva todo", donde solo una cadena sobrevive mientras todos los bloques en competencia quedan huérfanos. Los bloques huérfanos, aunque contienen transacciones válidas y representan un trabajo computacional real, no contribuyen a la seguridad de la red ni a la capacidad de procesamiento de transacciones. Este diseño garantiza un ordenamiento claro pero inherentemente limita el rendimiento, ya que solo se puede aceptar un bloque en cada nivel de altura. En este ejemplo, puede ver cómo Bitcoin descarta los bloques.</p>
  <div class="img-container"><img alt="Bloques huérfanos en Bitcoin" src="images/image38.png"></div>

  <h4 class="subsection-title">Selección de Trabajo Azul de Kaspa - Integración Paralela</h4>
  <p>El protocolo GHOSTDAG de Kaspa amplía este enfoque al operar dentro de una estructura de Grafo Dirigido Acíclico (DAG) donde múltiples bloques pueden coexistir y contribuir a la seguridad de la red. En lugar de descartar bloques en competencia, GHOSTDAG los clasifica como "azules" (honestos, que contribuyen al consenso) o "rojos" (potencialmente conflictivos pero aún retenidos). La métrica de "trabajo azul" representa la prueba de trabajo acumulada solo de los bloques azules en el DAG. Esta acumulación selectiva garantiza que solo los bloques válidos por consenso contribuyan al cálculo de seguridad, mientras se preserva el trabajo y las transacciones de los bloques rojos dentro de la estructura general. En este ejemplo, puede ver que el bloque que fue descartado por Bitcoin se incluye en el DAG de Kaspa, incluso cuando k = 0.</p>
  <div class="img-container"><img alt="Integración paralela en Kaspa (bloques azules y rojos)" src="images/image20.png"></div>

  <h4 class="subsection-title">Selección de Padres y Formación de la Cadena Principal</h4>
  <p>Cuando un nuevo bloque entra en el DAG, GHOSTDAG debe seleccionar un "Padre Seleccionado" entre varios candidatos posibles. Este proceso de selección examina el valor de "trabajo azul" de cada padre potencial y elige el que tenga el valor de "trabajo azul" acumulado más alto de los bloques honestos. Aquí está el bloque B, seleccionando el mejor padre (el padre con más trabajo) entre sus padres.</p>
  <div class="img-container"><img alt="Selección de padre y formación de la cadena principal" src="images/image39.png"></div>
  <p>Este padre seleccionado se convierte en la base para establecer una cadena principal dentro del DAG. La cadena principal proporciona un mecanismo de ordenamiento determinista similar a la cadena lineal de Bitcoin, pero opera en el entorno DAG más complejo. Después de seleccionar al padre principal, el protocolo procesa todos los bloques restantes en lo que se denomina el "Mergeset", bloques que se incluyen en el DAG pero que no fueron elegidos como el Padre Seleccionado. Después de seleccionar un padre, podemos seguir a los Padres Seleccionados a través del DAG; esto crea una cadena que puede ver en la imagen aquí.</p>
  <div class="img-container"><img alt="Siguiendo a los Padres Seleccionados a través del DAG" src="images/image10.png"></div>

  <h4 class="subsection-title">Ordenamiento y Procesamiento de Transacciones</h4>
  <p>La cadena principal creada por la selección de "trabajo azul" sirve como mecanismo de ordenamiento principal para el procesamiento de transacciones. Las transacciones se procesan primero desde el Padre Seleccionado, luego desde los bloques Mergeset en un orden acordado por consenso. Esto crea una secuencia determinista que todos los nodos pueden reproducir, asegurando un ordenamiento consistente de las transacciones en toda la red.</p>

  <h3 class="section-title">Diferencias Arquitectónicas Fundamentales</h3>
  <p><b>Enfoque de Bitcoin:</b> Crea una única secuencia lineal donde cada bloque tiene exactamente un padre. Los conflictos resultan en la exclusión permanente de los bloques en competencia, y solo la cadena ganadora contribuye a la seguridad de la red.</p>
  <p><b>Enfoque de Kaspa:</b> Mantiene una estructura DAG donde los bloques pueden tener múltiples padres e hijos. Los conflictos se resuelven mediante la clasificación en lugar de la exclusión, lo que permite que múltiples bloques contribuyan a la seguridad de la red mientras se mantiene el consenso a través de la cadena principal.</p>

  <h3 class="section-title">Implicaciones para el Rendimiento y la Seguridad</h3>
  <p>El enfoque lineal de Bitcoin ofrece sólidas garantías de seguridad, pero limita el rendimiento a aproximadamente un bloque cada 10 minutos. El hecho de que los bloques en competencia queden huérfanos representa un desperdicio de recursos computacionales y una pérdida de capacidad de transacción.</p>
  <p>El sistema de "trabajo azul" de Kaspa permite un rendimiento mucho mayor mientras mantiene las propiedades de seguridad. Al preservar tanto los bloques azules como los rojos en el DAG, el sistema captura una porción mayor del trabajo computacional y la capacidad de procesamiento de transacciones de la red. La cadena principal garantiza un ordenamiento determinista a pesar de la mayor complejidad, lo que permite la creación de bloques paralelos sin sacrificar la fiabilidad del consenso.</p>

  <h3 class="section-title">Reversión de Bitcoin en 2013: Una lección de finalidad</h3>
  <p>En marzo de 2013, la red Bitcoin experimentó un evento crítico que contradecía su principio fundamental de que "la cadena más larga es la cadena válida".</p>
  <ol>
      <li><strong>Una división de la cadena:</strong> Un minero que utilizaba la versión 0.8 de Bitcoin Core produjo un bloque incompatible con las versiones anteriores (0.7). Esto provocó una división de la cadena (bifurcación).</li>
      <li><strong>La coordinación social superó al protocolo:</strong> Aunque la cadena 0.8 se hizo más larga, los desarrolladores principales y los grandes pools de minería se coordinaron socialmente para abandonar esta cadena y volver a la cadena 0.7, más corta pero compatible.</li>
      <li><strong>La finalidad se rompió:</strong> 24 bloques de la cadena 0.8 quedaron huérfanos. Las transacciones que contenían, una vez consideradas válidas, fueron borradas del historial canónico de Bitcoin.</li>
  </ol>
  <p>Este evento demostró que el consenso de Bitcoin no es puramente determinista y puede requerir intervención humana. En Kaspa, tales divisiones son imposibles. Todos los bloques, incluso si se minan simultáneamente, se incluyen en el DAG, y GHOSTDAG selecciona un historial ordenado de forma consistente y algorítmica. No hay necesidad de reversiones o coordinación social; la finalidad es determinista.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="chapter14">Capítulo 14: Visión de Kaspa para la Capa 2: ZK Rollups y Bridging</h2>
  <h3 class="section-title">La necesidad de soluciones de Capa 2</h3>
  <p>Si bien Kaspa ofrece una escalabilidad impresionante en su capa base (Capa 1), el futuro de las aplicaciones descentralizadas complejas (DeFi, juegos, etc.) se basa en las soluciones de Capa 2. Estas permiten que los cálculos complejos se ejecuten fuera de la cadena principal, mientras se benefician de su seguridad. Kaspa se centra en "ZK-Rollups Basados", donde la Capa 1 (Kaspa) sirve como capa de secuenciación, disponibilidad de datos y liquidación.</p>

  <h3 class="section-title">El desafío: Prueba en el momento de la inclusión vs. Incertidumbre de ejecución</h3>
  <p>Las L1 paralelizadas como Kaspa introducen "incertidumbre de ejecución": las transacciones se incluyen en el DAG antes de que se determine su orden global final. Esto es una ventaja para la resistencia a MEV, ya que evita que los mineros predigan la secuencia exacta.</p>
  <p>Sin embargo, esto crea un conflicto con los ZK-Rollups, que, idealmente, requerirían "prueba en el momento de la inclusión". Para generar una prueba ZK, el pre-estado debe ser conocido e inequívoco. Pero en Kaspa, este estado no está definido en el momento de la inclusión debido al procesamiento paralelo.</p>
  <p>La solución de Kaspa es optar por el consenso multilíder y su incertidumbre de ejecución. Por lo tanto, las pruebas ZK deben posponerse y enviarse a la L1 solo después de que el orden de las transacciones haya convergido y se haya establecido un estado claro. Esto introduce un nuevo desafío: ¿qué pasa si la prueba requerida nunca llega?</p>

  <h3 class="section-title">Liquidación de Pruebas con Límite de Tiempo</h3>
  <p>El modelo propuesto es la "liquidación de pruebas con límite de tiempo".</p>
  <ol>
      <li>Los datos de la transacción se publican primero en la L1 (disponibilidad de datos).</li>
      <li>La liquidación final de sus efectos en la L1 depende de la presentación y verificación de una prueba ZK dentro de un período de tiempo definido (T).</li>
      <li>Si una parte involucrada en una operación no proporciona su prueba dentro de este plazo, la operación falla, con sanciones para garantizar la responsabilidad.</li>
  </ol>
  <p>Este modelo permite confirmaciones optimistas rápidas del lado del usuario, mucho antes de la liquidación final en la L1, ya que cada rollup tiene un interés directo en enviar su prueba para mantener su propia "vivacidad".</p>

  <h3 class="section-title">KIP-15 y Nodos de Archivo de Transacciones Aceptadas (ATANs)</h3>
  <p>Un problema fundamental para las L2 en Kaspa es la poda. ¿Cómo puede una L2 referirse a datos de transacciones que han sido podados de la L1? Las pruebas ZK son la solución a largo plazo, pero se necesita una solución provisional.</p>
  <p>Este es el propósito de KIP-15: introducir <strong>Nodos de Archivo de Transacciones Aceptadas (ATANs)</strong>. Un ATAN se sitúa entre un nodo completo podado y un nodo de archivo completo.</p>
  <ul>
      <li>No almacena datos completos de las transacciones.</li>
      <li>Almacena los encabezados de la cadena seleccionada y los <strong>hashes</strong> de todas las transacciones.</li>
  </ul>
  <p>Un hash de transacción tiene solo 32 bytes, lo que representa una compresión masiva en comparación con la transacción en sí. Un ATAN puede almacenar años de historial de hashes de transacciones con requisitos de almacenamiento razonables (estimado en unos 3-5 TB por año a plena capacidad). Esto permite que una L2 demuestre la existencia y el orden de cualquier transacción pasada sin necesidad de un nodo de archivo completo, resolviendo así el problema de la disponibilidad de datos en un entorno podado.</p>

  <h3 class="section-title">Diseño de Puente Canónico L1<>L2</h3>
  <p>Para permitir que los fondos (KAS) fluyan entre L1 y L2, se necesita un "puente canónico".</p>
  <ul>
      <li><strong>Entrada (L1 a L2):</strong> Un usuario envía KAS a una dirección de delegación estática en la L1. Esta operación es validada inmediatamente por la L1, y los fondos están disponibles casi instantáneamente en la L2.</li>
      <li><strong>Salida (L2 a L1):</strong> Una transacción de salida requiere autorización interna en la L2. Su validez debe confirmarse en la L1 mediante el envío de una prueba ZK.</li>
  </ul>
  <p>Para ello, Kaspa utiliza scripts de "delegación". En lugar de enviar fondos a la dirección de estado del rollup (que es dinámica), los usuarios envían a direcciones estáticas que delegan su autorización de gasto a la prueba ZK proporcionada por el rollup. Esto simplifica la experiencia del usuario y la gestión de fondos del puente.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="chapter15">Capítulo 15: La Red Igra: Un Caso de Estudio del ZK Rollup Compatible con EVM de Kaspa</h2>
  <h3 class="section-title">Descripción General de Igra</h3>
  <p>Igra Network es un excelente ejemplo práctico de la visión de Kaspa para la Capa 2. Es un <strong>ZK rollup compatible con EVM</strong> que utiliza de forma única el BlockDAG de Kaspa como secuenciador descentralizado y capa de liquidación.</p>
  <p>Esta arquitectura tiene como objetivo combinar la seguridad similar a Bitcoin con la velocidad y versatilidad de las cadenas programables modernas, resolviendo limitaciones críticas de las soluciones actuales de Capa 2.</p>

  <h3 class="section-title">Componentes Clave</h3>
  <ul>
      <li><strong>Capa Base (Kaspa):</strong> Sirve como secuenciador descentralizado. El orden de las transacciones de Igra se fija en el BlockDAG de Kaspa por sus nodos de minería.</li>
      <li><strong>Nodo Igra:</strong> Mantiene el estado completo de la L2 y ejecuta transacciones EVM. Extrae las transacciones secuenciadas de la L1 y las ejecuta.</li>
      <li><strong>Igra Relay / RPC:</strong> Proporciona el puente entre los usuarios y la red. Expone interfaces RPC estándar de Ethereum, lo que permite a los usuarios interactuar con Igra utilizando billeteras como MetaMask.</li>
  </ul>

  <h3 class="section-title">Mecanismo de Puente y Despliegue</h3>
  <p>Igra utiliza un enfoque de puente multifase para su token nativo, $iKAS, que es una versión envuelta de KAS.</p>
  <ol>
      <li><strong>Fase 1 (Puente Comunitario):</strong> Inicialmente, el puente se basa en una billetera multisig (m-de-n) controlada por firmantes elegidos por la comunidad. Este es un modelo de confianza similar al utilizado para los fondos comunitarios de muchas criptomonedas. Para retirar fondos, se requiere que los firmantes procesen las solicitudes, con salvaguardias para garantizar una transición a un sistema sin confianza.</li>
      <li><strong>Fase 2 (Puente MPC/ZK):</strong> En el futuro, este puente será reemplazado por una solución sin confianza.
          <ul>
              <li><strong>Puente MPC (Computación Multipartita):</strong> Utiliza técnicas criptográficas como FROST para permitir que un conjunto de validadores firmen transacciones sin que ninguno de ellos tenga la clave secreta completa. Esto permite un puente sin permisos.</li>
              <li><strong>Puente ZK:</strong> La solución definitiva. Un usuario puede enviar una prueba ZK a la L1 demostrando que quemó $iKAS en la L2. Un script en la L1 verificará esta prueba y desbloqueará la cantidad correspondiente de KAS.</li>
          </ul>
      </li>
  </ol>

  <h3 class="section-title">La Red de Prueba Caravel</h3>
  <p>El despliegue de Igra se realiza por etapas, comenzando con la red de prueba "Caravel". Este lanzamiento se lleva a cabo en varias fases:</p>
  <ol>
      <li><strong>Activación:</strong> La red se activa en la red de prueba de Kaspa.</li>
      <li><strong>Probadores de la Comunidad:</strong> El software del nodo se distribuye a un grupo limitado de probadores para aumentar gradualmente la actividad de la red.</li>
      <li><strong>Acceso Público:</strong> El software se hace público, permitiendo que cualquiera ejecute un nodo y participe.</li>
  </ol>
  <p>Este cuidadoso proceso de despliegue es esencial, ya que Caravel lleva el protocolo completo de Ethereum al consenso de Kaspa, que opera a velocidades aún inexploradas en el mundo EVM. Se necesitan pruebas intensivas y varias iteraciones para garantizar la estabilidad y el rendimiento.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="chapter16">Capítulo 16: Rendimiento de Transacciones y Colisiones en el BlockDAG de Kaspa</h2>
  <h3 class="section-title">El Desafío de las Colisiones de Transacciones</h3>
  <p>Lo que hace que los DAG sean increíblemente rápidos es la capacidad de paralelizar: dado que los bloques creados en paralelo se consideran válidos, aumentar la tasa de bloques paralelos no daña la seguridad. Sin embargo, surge una pregunta: si creamos 10 bloques por segundo, ¿nuestro rendimiento de transacciones es realmente 10 veces mayor?</p>
  <p>No del todo. El matiz es que los bloques paralelos pueden contener la misma transacción, y no es justo contar la misma transacción varias veces. Deberíamos estar interesados en el <strong>TPS efectivo</strong>, es decir, el número de transacciones únicas incluidas en promedio.</p>

  <h3 class="section-title">Análisis de Selección Aleatoria</h3>
  <p>Asumiendo que los mineros eligen las transacciones a incluir de forma aleatoria (lo cual es una aproximación razonable, como veremos), podemos analizar el TPS efectivo.</p>
  <p>El análisis matemático muestra que incluso en el peor de los casos (donde la capacidad del bloque coincide exactamente con el número de transacciones disponibles en el mempool), la red incluye al menos <strong>(1 - 1/e) ≈ 62.3%</strong> de transacciones únicas. Este es un límite inferior; en la práctica, cuando el mempool es más grande que la capacidad del bloque, la eficiencia tiende al 100%.</p>
  <p>El resultado es que el TPS efectivo aumenta casi linealmente con la tasa de bloques. Un aumento de 10 veces en la tasa de bloques se traduce en un aumento de 8-9 veces en el TPS efectivo, lo cual es una mejora significativa.</p>

  <h3 class="section-title">¿Qué pasa con los Mineros Deshonestos?</h3>
  <p>Uno podría preocuparse de que los mineros "codiciosos" intentaran manipular la selección de transacciones para maximizar sus ganancias, por ejemplo, eligiendo todos las mismas transacciones con tarifas altas, lo que aumentaría las colisiones y reduciría el TPS efectivo.</p>
  <p>La teoría de juegos nos muestra que esta no es una estrategia óptima. La selección aleatoria es un "equilibrio débil". Esto significa que si un solo minero se desvía de esta estrategia, puede obtener una ligera ventaja. Sin embargo, si muchos mineros se desvían y todos eligen las mismas transacciones con tarifas altas, terminan compitiendo directamente por las mismas tarifas, y su beneficio esperado disminuye. Al final, la estrategia más racional para un minero (que no puede predecir lo que harán los demás) es diversificar sus elecciones, lo que se aproxima a la selección aleatoria.</p>

  <h3 class="section-title">Posibles Soluciones para Altas Colisiones</h3>
  <p>Si, en la práctica, se observara una alta tasa de colisiones, se podrían implementar varias soluciones:</p>
  <ol>
      <li><strong>Agrupación de Transacciones:</strong> Se podría exigir que los bloques solo incluyan transacciones cuyo hash coincida con ciertos dígitos del propio hash del bloque. Esto dividiría las transacciones en "cubos", y los bloques solo competirían por las transacciones en el mismo cubo.</li>
      <li><strong>Mecanismo de Subasta Monopolística:</strong> Un mecanismo en el que los mineros pueden incluir las transacciones que deseen, pero las tarifas de todas las transacciones en el bloque se establecen al nivel de la tarifa más baja entre las transacciones incluidas. Esto incentiva a los mineros a incluir más transacciones (para aumentar el volumen) en lugar de centrarse solo en las que pagan más, lo que naturalmente fomenta la diversificación.</li>
  </ol>
  <p>En conclusión, aunque las colisiones de transacciones son una consideración en los BlockDAG, la arquitectura de Kaspa y la dinámica de la teoría de juegos garantizan que el rendimiento efectivo se mantenga alto y escale de forma robusta con la tasa de bloques.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="chapter17">Capítulo 17: Mercado de Tarifas de Kaspa: Una Perspectiva de la Teoría de Juegos</h2>
  <h3 class="section-title">La Importancia del Mercado de Tarifas</h3>
  <p>El mercado de tarifas de una criptomoneda es extremadamente importante para su seguridad a largo plazo. Una vez que las recompensas por bloque se vuelven insignificantes, las tarifas de transacción siguen siendo el subsidio principal para la seguridad de la red. Por lo tanto, es crucial comprender la dinámica del mercado de tarifas que induce un protocolo.</p>

  <h3 class="section-title">Los Tres Males del Mercado de Tarifas de Bitcoin</h3>
  <p>El mercado de tarifas de Bitcoin, debido a su consenso de "un solo líder por ronda", exhibe propiedades que pueden describirse como "tres males":</p>
  <ol>
      <li><strong>Carrera hacia el fondo:</strong> Cuando la red no está congestionada, la demanda es menor que la oferta de espacio de bloque. Los usuarios no tienen incentivos para pagar tarifas altas, ya que sus transacciones se incluirán de todos modos. Las tarifas tienden al mínimo, lo que puede hacer que la minería no sea rentable y amenazar la seguridad de la red.</li>
      <li><strong>Aberración de precios:</strong> Cuando la red está congestionada, un aumento muy pequeño en las tarifas puede hacer que una transacción pase de "nunca incluida" a "incluida en el siguiente bloque". El precio no refleja un servicio gradual.</li>
      <li><strong>Hambruna:</strong> En una red congestionada, las transacciones de baja tarifa pueden quedar excluidas perpetuamente, ya que nunca pueden superar a las transacciones de alta tarifa. Esto crea una barrera de entrada y plantea preguntas sobre el ethos igualitario de la cadena de bloques.</li>
  </ol>
  <p>Estas dinámicas son una consecuencia directa de que un solo minero gane todo el bote en cada ronda.</p>

  <h3 class="section-title">Cómo el BlockDAG Multilíder de Kaspa Mejora el Mercado de Tarifas</h3>
  <p>En Kaspa, múltiples mineros crean bloques en paralelo en cada ronda (multilíderes). Si varios mineros incluyen la misma transacción, comparten la recompensa probabilísticamente. Esto cambia radicalmente la dinámica del juego para mineros y usuarios.</p>
  <ul>
      <li><strong>Contra la carrera hacia el fondo:</strong> Debido a que los mineros están en competencia, se vuelve racional para ellos incluir transacciones incluso si la red solo se utiliza parcialmente, para diversificar sus flujos de ingresos y evitar la competencia directa. El análisis muestra que el mercado de tarifas se activa tan pronto como la red alcanza <strong>1/k</strong> de su capacidad (donde k es el número de líderes por ronda), en lugar del 100% para Bitcoin. Con 10 líderes por ronda, el mercado se activa tan pronto como se utiliza el 10% de la capacidad.</li>
      <li><strong>Contra la hambruna y la aberración:</strong> Los mineros tienen un incentivo para incluir una mezcla de transacciones, incluidas las de tarifas más bajas. No siempre es óptimo luchar por las pocas transacciones que pagan más, ya que la probabilidad de ganar esas tarifas se reduce por la competencia. Esto crea una curva de servicio mucho más suave: un ligero aumento en las tarifas conduce a un ligero aumento en la probabilidad de inclusión, en lugar de un cambio repentino. Las transacciones de baja tarifa aún tienen una posibilidad (aunque pequeña) de ser incluidas, lo que evita la hambruna. Una baja probabilidad de inclusión en una ronda se traduce en un tiempo de espera promedio razonable, en lugar de una espera infinita.</li>
  </ul>
  <p>En conclusión, la arquitectura multilíder de Kaspa, una consecuencia directa de su BlockDAG de alta frecuencia, crea un mercado de tarifas inherentemente más saludable, estable y justo. Al suavizar las dinámicas extremas de "todo o nada" de las cadenas de bloques de un solo líder, Kaspa construye una base económica más robusta para su seguridad a largo plazo.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="conclusion">Conclusión</h2>
  <div class="conclusion">
    <p>Al final de este viaje a través de la arquitectura y la filosofía de Kaspa, una conclusión destaca: estamos siendo testigos de una verdadera evolución en el campo de las tecnologías de libro mayor distribuido. Kaspa no es simplemente otra criptomoneda; es un rediseño fundamental de los principios establecidos por Bitcoin, diseñado para la era digital de alta velocidad.</p>
    <p>Hemos visto cómo su BlockDAG, gobernado por el protocolo de consenso GHOSTDAG, desmantela el cuello de botella de la cadena lineal. Al permitir la creación e integración paralela de bloques, Kaspa elimina el desperdicio de bloques huérfanos, maximiza la eficiencia energética de la prueba de trabajo y logra velocidades de transacción y confirmación que antes se consideraban imposibles para un sistema PoW descentralizado.</p>
    <p>Hemos explorado sus ingeniosas soluciones de almacenamiento, con un sistema de poda multinivel que garantiza la descentralización a largo plazo al mantener bajos los requisitos de hardware para los nodos. También hemos profundizado en su visión para el futuro, con soluciones de Capa 2 como los ZK-Rollups, que prometen aportar una programabilidad e interoperabilidad complejas sin sacrificar la seguridad de la capa base.</p>
    <p>Kaspa nos muestra que el trilema de la blockchain, la idea de que uno debe elegir entre seguridad, escalabilidad y descentralización, puede no ser una ley inmutable, sino más bien una limitación de las arquitecturas de primera generación. Inspirándose en los principios de la física y la economía, Kaspa ha diseñado un sistema que tiende a la máxima eficiencia, mínima fricción y óptima retención de valor.</p>
    <p>El futuro de Kaspa es prometedor. Con actualizaciones como DAGKnight que formalizarán la finalidad y la investigación en curso sobre la resistencia a MEV y los oráculos, el proyecto continúa empujando los límites de lo posible. Ya sea que Kaspa se convierta en la columna vertebral de la próxima generación de aplicaciones descentralizadas o coexista con otros sistemas, una cosa es segura: ya ha dejado una marca indeleble en la historia de las criptomonedas al demostrar que un sistema monetario puede ser tan sólido como el oro y tan rápido como la luz.</p>
    <p>Esperamos que este libro le haya proporcionado las claves para comprender la profundidad y la elegancia de Kaspa. El viaje acaba de comenzar, y la mejor manera de continuarlo es involucrarse, hacer preguntas y seguir aprendiendo.</p>
  </div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="appendixA">Apéndice A: Recursos Adicionales</h2>
  <p>Para aquellos que deseen profundizar en su comprensión de Kaspa, aquí hay una lista de recursos esenciales, que van desde artículos introductorios hasta documentos de investigación fundamentales.</p>

  <h4>Artículos de Introducción</h4>
  <ul>
    <li><strong>Kaspa 101</strong>: Un excelente punto de partida para entender cómo funciona GHOSTDAG. <a href="https://michaelsutton.github.io/2022-04-23-kaspa-101-part1/">Leer aquí</a></li>
    <li><strong>Escalando Bitcoin con BlockDAG</strong>: Explica por qué BlockDAG es una solución viable a las limitaciones de Bitcoin. <a href="https://someone235.medium.com/scaling-bitcoin-with-blockdag-d785174a3402">Leer aquí</a></li>
    <li><strong>Introducción a la Poda de Kaspa</strong>: Una introducción al mecanismo de poda de Kaspa. <a href="https://hashdag.medium.com/in-which-mayday-mayday-we-are-syncing-about-bf05ad58957a">Leer aquí</a></li>
    <li><strong>Kaspa GhostDAG 101 (Video)</strong>: Una descripción general en video completa de los conceptos técnicos. <a href="https://www.youtube.com/watch?v=nhI2zo44dfc">Ver aquí</a></li>
  </ul>

  <h4>Documentos de Investigación (Profundización)</h4>
  <ul>
    <li><strong>PHANTOM y GHOSTDAG</strong>: El artículo académico que sentó las bases del consenso de Kaspa. <a href="https://eprint.iacr.org/2018/104.pdf">Leer PDF</a></li>
    <li><strong>El Protocolo DAGKnight</strong>: El protocolo de consenso de próxima generación de Kaspa, diseñado para una finalidad rápida y resistencia a ataques. <a href="https://eprint.iacr.org/2022/1494.pdf">Leer PDF</a></li>
    <li><strong>Prunality</strong>: El documento que detalla la teoría detrás del mecanismo de poda de Kaspa. <a href="https://github.com/kaspanet/docs/blob/main/Reference/prunality/Prunality.pdf">Leer PDF</a></li>
    <li><strong>Whitepaper de Bitcoin</strong>: El documento original de Satoshi Nakamoto, para contexto histórico. <a href="https://bitcoin.org/bitcoin/bitcoin.pdf">Leer PDF</a></li>
  </ul>

  <h4>Código y Desarrollo</h4>
  <ul>
    <li><strong>Rusty-Kaspa (Repositorio Principal)</strong>: El código fuente del nodo Kaspa, escrito en Rust. <a href="https://github.com/kaspanet/rusty-kaspa">Ver en GitHub</a></li>
    <li><strong>Propuestas de Mejora de Kaspa (KIPs)</strong>: El repositorio que contiene todas las Propuestas de Mejora de Kaspa. <a href="https://github.com/kaspanet/kips">Ver en GitHub</a></li>
  </ul>

  <h4>Comunidad y Discusión</h4>
  <ul>
    <li><strong>Discord</strong>: El lugar principal para discusiones técnicas y comunitarias. Canales recomendados: <code>#research-general</code>, <code>#development</code>. <a href="https://discord.gg/kaspa">Unirse a Discord</a></li>
    <li><strong>Telegram (I+D)</strong>: Un grupo donde colaboran desarrolladores e investigadores. <a href="https://t.me/kasparnd">Unirse en Telegram</a></li>
    <li><strong>Foro de Investigación</strong>: Para discusiones en profundidad sobre KIPs y nuevos conceptos técnicos. <a href="https://research.kas.pa/">Visitar foro</a></li>
  </ul>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="appendixB">Apéndice B: Análisis Matemático de Colisiones de Transacciones (Simplificado)</h2>
  <p>Este capítulo explora el problema del TPS efectivo (transacciones por segundo) en un BlockDAG. Cuando se crean múltiples bloques en paralelo, pueden contener las mismas transacciones, lo que reduce el rendimiento único. El análisis muestra que incluso con la selección aleatoria de transacciones por parte de los mineros, el rendimiento efectivo sigue siendo alto.</p>
  <p>La idea clave es que la probabilidad de que dos mineros elijan la misma transacción disminuye a medida que aumenta el pool de transacciones pendientes (mempool). El análisis matemático (utilizando la teoría de la probabilidad y las series de Taylor) muestra que incluso en un escenario en el que la capacidad del bloque coincide exactamente con el número de transacciones disponibles, la red incluye al menos <strong>(1 - 1/e) ≈ 62.3%</strong> de transacciones únicas. Esta cifra representa un mínimo; en la práctica, la eficiencia suele ser mucho mayor.</p>
  <p>Además, la teoría de juegos sugiere que los mineros no tienen un incentivo significativo para desviarse de esta selección cuasi-aleatoria. Si todos los mineros intentan elegir las transacciones que pagan más, terminan compitiendo por las mismas tarifas, lo que disminuye su beneficio esperado. Una estrategia de diversificación (selección aleatoria) es, por lo tanto, un equilibrio estable (un "equilibrio débil").</p>
  <p>En resumen, el paralelismo de Kaspa no daña significativamente el rendimiento efectivo, que aumenta casi linealmente con la tasa de bloques.</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="appendixC">Apéndice C: Análisis Matemático del Mercado de Tarifas (Simplificado)</h2>
  <p>Este capítulo analiza la dinámica del mercado de tarifas utilizando la teoría de juegos, comparando el modelo de "un solo líder" de Bitcoin con el modelo de "multilíder" de Kaspa.</p>
  <h4>Los Tres Males del Mercado de Tarifas de Bitcoin:</h4>
  <ol>
    <li><strong>Carrera hacia el fondo</strong>: Cuando la red no está congestionada, los usuarios no tienen incentivos para pagar tarifas altas, ya que sus transacciones se incluirán de todos modos. Las tarifas tienden al mínimo, lo que amenaza la seguridad a largo plazo de la red.</li>
    <li><strong>Aberración de precios</strong>: Cuando la red está congestionada, un aumento muy pequeño en las tarifas puede hacer que una transacción pase de "nunca incluida" a "incluida en el siguiente bloque". El precio no refleja un servicio gradual.</li>
    <li><strong>Hambruna</strong>: En una red congestionada, las transacciones de baja tarifa pueden quedar excluidas perpetuamente, creando una barrera de entrada para los usuarios menos afortunados.</li>
  </ol>
  <h4>Cómo el BlockDAG de Kaspa resuelve estos problemas:</h4>
  <p>En Kaspa, múltiples mineros crean bloques en paralelo (multilíderes). Si varios mineros incluyen la misma transacción, comparten la recompensa (probabilísticamente). Esto cambia radicalmente la dinámica:</p>
  <ul>
    <li><strong>Contra la carrera hacia el fondo</strong>: Debido a que los mineros están en competencia, se vuelve racional incluir transacciones incluso si la red solo se utiliza parcialmente. El análisis muestra que el mercado de tarifas se activa tan pronto como la red alcanza <strong>1/k</strong> de su capacidad (donde k es el número de líderes por ronda), en lugar del 100% para Bitcoin. Con 10 líderes por ronda, el mercado se activa tan pronto como se utiliza el 10% de la capacidad.</li>
    <li><strong>Contra la hambruna y la aberración</strong>: Los mineros tienen un incentivo para incluir una mezcla de transacciones, incluidas las de tarifas más bajas. No siempre es óptimo luchar por las pocas transacciones que pagan más, ya que la probabilidad de ganar esas tarifas se reduce por la competencia. Esto crea una curva de servicio más suave: un ligero aumento en las tarifas conduce a un ligero aumento en la probabilidad de inclusión, en lugar de un cambio repentino. Las transacciones de baja tarifa aún tienen una posibilidad de ser incluidas, lo que evita la hambruna.</li>
  </ul>
  <p>En conclusión, la arquitectura multilíder de Kaspa crea un mercado de tarifas más saludable, estable y justo, lo cual es esencial para la seguridad y viabilidad a largo plazo del protocolo.</p>

</div>
</body>
</html>