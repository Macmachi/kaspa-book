<!DOCTYPE html>
<html lang="ja">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="content-type">
<title>Kaspa: 次世代プロトコル</title>
<style type="text/css">
  body {
    font-family: 'Arial', sans-serif;
    line-height: 1.6;
    color: #333;
    background-color: #f8f9fa;
    margin: 0;
    padding: 0;
  }
  .container {
    max-width: 800px;
    margin: 20px auto;
    padding: 20px;
    background-color: #ffffff;
    border: 1px solid #dee2e6;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
  }
  h1, h2, h3, h4 {
    color: #2c3e50;
    line-height: 1.3;
    page-break-after: avoid;
  }
  h1.book-title {
    font-size: 2.5em;
    text-align: center;
    margin-bottom: 0.5em;
    border-bottom: 2px solid #3498db;
    padding-bottom: 10px;
  }
  h2.chapter-title {
    font-size: 2em;
    margin-top: 1.5em;
    border-bottom: 1px solid #bdc3c7;
    padding-bottom: 5px;
  }
  h3.section-title {
    font-size: 1.5em;
    margin-top: 1.2em;
    color: #34495e;
  }
  h4.subsection-title {
    font-size: 1.2em;
    margin-top: 1em;
    color: #7f8c8d;
  }
  p {
    text-align: justify;
    margin-bottom: 1em;
  }
  .img-container {
    display: block;
    width: 100%;
    max-width: 600px;
    height: auto;
    margin: 20px auto;
    text-align: center;
    box-sizing: border-box;
  }
  .img-container img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0 auto;
  }
  .author-date {
    text-align: right;
    font-style: italic;
    color: #7f8c8d;
    margin-bottom: 2em;
  }
  .simplified-def {
    background-color: #ecf0f1;
    border-left: 5px solid #3498db;
    padding: 15px;
    margin: 1.5em 0;
  }
  .simplified-def b {
    color: #2980b9;
  }
  ul {
    list-style-type: disc;
    margin-left: 20px;
    padding-left: 20px;
  }
  li {
    margin-bottom: 0.5em;
  }
  blockquote {
    border-left: 4px solid #bdc3c7;
    padding-left: 15px;
    margin-left: 0;
    font-style: italic;
    color: #7f8c8d;
  }
  hr.chapter-break {
    page-break-before: always;
    border: 0;
  }
  .cover-page {
    text-align: center;
    padding: 100px 20px;
    border: 2px solid #2c3e50;
    margin-bottom: 50px;
  }
  .cover-page .title {
    font-size: 3em;
    color: #2c3e50;
  }
  .cover-page .subtitle {
    font-size: 1.5em;
    color: #7f8c8d;
  }
  .cover-page .author {
    margin-top: 50px;
    font-size: 1.2em;
  }
  .conclusion, .introduction {
      padding: 20px;
      background-color: #eaf2f8;
      border-radius: 5px;
  }
/* 目次スタイル */
.table-of-contents {
  background-color: #f0f8ff; /* Light blue background */
  border: 1px solid #cceeff; /* Light blue border */
  padding: 20px;
  margin: 20px auto;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.table-of-contents .chapter-title {
  text-align: center;
  margin-bottom: 20px;
  color: #2c3e50;
  border-bottom: 1px solid #aaddff;
  padding-bottom: 10px;
}

.table-of-contents ul {
  list-style: none; /* Remove default bullet points */
  padding-left: 0;
}

.table-of-contents ul ul {
  padding-left: 20px; /* Indent for subsections */
  margin-top: 5px;
}

.table-of-contents li {
  margin-bottom: 8px;
}

.table-of-contents li a {
  text-decoration: none;
  color: #3498db; /* Blue link color */
  font-weight: bold;
  transition: color 0.2s ease;
}

.table-of-contents li a:hover {
  color: #2980b9; /* Darker blue on hover */
}

.table-of-contents ul ul li a {
  font-weight: normal; /* Normal font for subsections */
  font-size: 0.95em;
  color: #555; /* Slightly darker color for subsections */
}

.table-of-contents ul ul li a:hover {
  color: #333;
}

.table-of-contents .no-id-link {
    color: #7f8c8d; /* Grey out unlinked items */
    font-style: italic;
}
</style>
</head>
<body>
<div class="container">

  <div class="cover-page">
    <h1 class="title">Kaspa：次世代プロトコル</h1>
    <p class="subtitle">BlockDAG、コンセンサス、デジタル通貨の未来に関する包括的なガイド</p>
    <p class="author">コミュニティによって編集および加筆修正 (2025年7月27日)</p>
  </div>

  <hr class="chapter-break">

  <div class="introduction">
    <h2 class="chapter-title">はじめに</h2>
    <p>Kaspaに関するこの包括的なガイドへようこそ。Kaspaは、既存の技術を単に反復するだけでなく、根本的に再発明する暗号通貨です。何千ものプロジェクトが注目を集めるエコシステムにおいて、Kaspaは厳密なアプローチと深遠な革新によって際立っています。その目的は、スケーラビリティ、速度、分散化という従来のブロックチェーンの最も根本的な問題を、妥協することなく解決することです。</p>
    <p>本書は、Kaspaの根底にある複雑な概念を解き明かすことを目的としています。まず基本から始め、有向非巡回グラフ（DAG）とは何か、そしてKaspaのGHOSTDAGプロトコルがそれをどのように利用して、高速で安全かつ完全に分散化されたコンセンサスシステムを構築しているかを説明します。あなたが好奇心旺盛な開発者であろうと、基礎となる技術を理解したい投資家であろうと、あるいは単なる暗号通貨愛好家であろうと、本書はあなたを段階的に導くように設計されています。</p>
    <p>Kaspaがどのように「ブロックチェーンのトリレンマ」を解決したか、そのユニークなアーキテクチャがどのようにほぼ瞬時の確認を可能にするか、そして洗練されたプルーニングシステムによってどのようにデータストレージを持続的に管理しているかを探ります。また、MEV（最大抽出可能価値）に対する耐性、ZK-Rollupsによるレイヤー2ソリューションのビジョン、手数料市場の経済的ダイナミクスなど、より高度なトピックも扱います。</p>
    <p>この作品は、共同作業の成果です。Kaspaコミュニティの貢献者の皆様に深く感謝いたします。彼らの記事、研究、議論が本書の骨子を形成しました。内容の大部分は、公式ウェブサイト <strong><a href="https://kaspa.com/learn-kaspa">Kaspa.com/learn-kaspa</a></strong> の貴重なリソースや、主要な研究者や開発者の著作から翻案・翻訳されたものです。また、<strong>Cihan0x.ETH (<a href="https://x.com/cihan0xeth/status/1949361083883380833">@cihan0xeth</a>)</strong> のオリジナル分析に基づいた作品、そして <strong>BankQuote_DAG</strong> の洞察に満ちた分析が、この作品を大いに豊かにしてくれたことに特に感謝いたします。</p>
    <p>暗号通貨の世界で最も革新的なアーキテクチャの1つに飛び込む準備をしてください。Kaspaを理解する準備をしてください。</p>
  </div>

  <hr class="chapter-break">

<div class="table-of-contents">
      <h2 class="chapter-title">目次</h2>
      <ul>
          <li><a href="#h.sbugt7p65zq6">第1章：KaspaのBlockDAG</a>
              <ul>
                  <li><a href="#h.52y7zpxatzmc">DAG - 有向非巡回グラフ</a></li>
                  <li><a href="#h.r0onrjvzaye8">ビットコインとKaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.q9lxzgpefpuh">第2章：Kaspa - ボディとヘッダーの結合</a>
              <ul>
                  <li><a href="#h.3ezesbjpkjql">ブロックボディをヘッダーに固定する - マークルルート</a></li>
                  <li><a href="#h.emrhhaf2640n">ビットコインとKaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.y0ik307h70q9">第3章：Kaspaと「ビットコインのスケーラビリティ問題」</a>
              <ul>
                  <li><a href="#h.2jy3kmwufuue">Kaspaは「ビットコインのスケーラビリティ問題」を解決した - それは何？</a></li>
                  <li><a href="#h.v4bl36mx6e0u">ビットコインとKaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.1tq8u5wwr5up">第4章：MuHash</a>
              <ul>
                  <li><a href="#h.ny65anmiz0s">MuHashとは何か、Kaspaはどのようにそれを使用しているか？</a></li>
                  <li><a href="#h.focbph7aurgq">ビットコインとKaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.oy0kgniero14">第5章：KaspaのUTXOモデル</a>
              <ul>
                  <li><a href="#h.8nqvw067oam1">UTXOとは何か、Kaspaはどのようにそれを使用しているか？</a></li>
                  <li><a href="#h.5v09d76siagw">ビットコインとKaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.6x07cz5zmxim">第6章：親ブロックとマージセット</a>
              <ul>
                  <li><a href="#h.34xcaoqpznos">親ブロックとマージセットとは何か、Kaspaはどのようにそれらを使用しているか？</a></li>
                  <li><a href="#h.tsab66lazd4a">ビットコイン対Kaspa</a></li>
              </ul>
          </li>
          <li><a href="#h.x0nj4tecoh66">第7章：二次プルーニング</a>
              <ul>
                  <li><a href="#h.1wbq42gt63wc">二次プルーニングとは何か、Kaspaはどのようにそれを使用しているか？</a></li>
              </ul>
          </li>
          <li><a href="#h.mz2dlkhrvwd2">第8章：Kaspa GHOSTDAGの簡略化</a>
              <ul>
                  <li><a href="#h.hwkbrs8egi6p">GHOSTDAGとは何か、Kaspaはどのようにそれを使用しているか？</a></li>
              </ul>
          </li>
          <li><a href="#h.drxg3f8wwuwc">第9章：DAG用語</a>
              <!-- Note: Some subsections in Chapter 9 do not have IDs in the original HTML and thus cannot be linked directly. -->
          </li>
          <li><a href="#h.1uals18cttyl">第10章：一次プルーニング</a>
              <ul>
                  <li><a href="#h.3i8fyh1jrh8m">一次プルーニングとは何か、Kaspaはどのようにそれを使用しているか？</a></li>
              </ul>
          </li>
          <li><a href="#h.juf0jn9hl1ev">第11章：アーカイブノード対フルノード</a>
              <ul>
                  <li><a href="#h.knim47a94vo6">Kaspaアーカイブノード対プルーニングノード</a></li>
              </ul>
          </li>
          <li><a href="#h.xoj5wjv6tg4b">第12章：Kaspa：エネルギー効率の高い分散型アーキテクチャの進化</a>
              <ul>
                  <li><a href="#h.pfav0qmvzt92">はじめに：お金と効率の物理学</a></li>
                  <!-- Note: Some subsections in Chapter 12 do not have IDs in the original HTML and thus cannot be linked directly. -->
                  <li><a href="#h.y2juit6511i3">KaspaのBlockDAG：無駄な作業のない並列性</a></li>
                  <li><a href="#h.ttddfh4xlbpu">光速でのスループット達成</a></li>
                  <li><a href="#h.uttpgy92hgk">摩擦を減らし、価値をより良く保持する</a></li>
              </ul>
          </li>
          <li><a href="#h.e01avawvoirc">第13章：Kaspaとビットコインの順序付け</a>
              <!-- Note: Some subsections in Chapter 13 do not have IDs in the original HTML and thus cannot be linked directly. -->
          </li>
          <li><a href="#chapter14">第14章：Kaspaのレイヤー2ビジョン：ZKロールアップとブリッジング</a></li>
          <li><a href="#chapter15">第15章：Igraネットワーク：KaspaのEVM互換ZKロールアップのケーススタディ</a></li>
          <li><a href="#chapter16">第16章：KaspaのBlockDAGにおけるトランザクションスループットと衝突</a></li>
          <li><a href="#chapter17">第17章：Kaspaの手数料市場：ゲーム理論的視点</a></li>
          <li><a href="#conclusion">結論</a></li>
          <li><a href="#appendixA">付録A：追加リソース</a></li>
          <li><a href="#appendixB">付録B：トランザクション衝突の数学的分析（簡略化）</a></li>
          <li><a href="#appendixC">付録C：手数料市場の数学的分析（簡略化）</a></li>
      </ul>
  </div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.sbugt7p65zq6">第1章：KaspaのBlockDAG</h2>
  <div class="img-container"><img alt="KaspaのBlockDAG" src="images/image1.png"></div>
  <h3 class="section-title" id="h.52y7zpxatzmc">DAG - 有向非巡回グラフ</h3>
  <p>KaspaがBlockDAGであると聞いたことがあるかもしれませんが、それは何を意味するのでしょうか？この章は予備知識を前提としないように設計されているため、まずグラフ理論から始めます。最初にグラフとは何か、次に有向グラフとは何か、そして有向非巡回グラフについて説明し、最後にそれがビットコインとKaspaの両方にどのように適用されるかを説明します。</p>
  <p><b>グラフ</b> - グラフ理論は数学とコンピュータ科学の分野であり、エンティティ間の関係を表す構造であるグラフの研究に焦点を当てています。これらのグラフは、頂点（ノードまたは点とも呼ばれる）と、辺（リンクまたは線とも呼ばれる）によって接続されています。グラフは、頂点間の接続が相互である無向グラフと、接続が特定の方向を持つ有向グラフに分類されます。離散数学の主要な分野として、グラフ理論はこれらの構造を深く探求しています。次の図は、接続に方向がない単純な無向グラフを示しています。</p>
  <div class="img-container"><img alt="無向グラフ" src="images/image63.png"></div>
  <p><b>有向グラフ</b> - 有向グラフは、しばしばダイグラフとも呼ばれ、点間の接続に特定の方向がある関係を示すために使用される構造です。接続が両方向に行く通常のグラフとは異なり、有向グラフでは各辺が1つの頂点から別の頂点へ向かっています。最も単純な形式では、有向グラフは2つの主要な部分で構成されています。それは、頂点の集合と辺の集合であり、各辺は明確な方向を持つ頂点のペアです（ある頂点から別の頂点へ向かうが、逆方向ではない）。例えば、頂点Xから頂点Yへの辺がある場合、Xが始点、Yが終点です。この辺はXとYを接続します。別の辺がYからXへ向かうこともありますが、それは別の接続になります。この基本的な構成（単純有向グラフと呼ばれる）では、同じ2つの頂点間に同じ方向の複数の辺を持つことはできませんし、同じ頂点で始まり同じ頂点で終わる辺（ループと呼ばれる）を持つこともできません。次の図は、辺に方向がある有向グラフを示しています。2つのポインタを持つ辺は、それぞれ方向を持つ2つの辺を表していることに注意してください。</p>
  <div class="img-container"><img alt="有向グラフ" src="images/image70.png"></div>
  <p><b>有向非巡回グラフ</b> - は、サイクルを含まない有向グラフです。頂点と辺で構成されており、各辺は一方の頂点から他方の頂点への方向を持ち、辺の方向に従うと決して閉じたループにならないことが保証されます。有向グラフは、すべての辺の方向を尊重する線形順序で頂点を配置できる場合、DAGと呼ばれます。これはトポロジカル順序として知られています。次の図は、サイクル（またはループ）が見つからない有向非巡回グラフを示しています。</p>
  <div class="img-container"><img alt="有向非巡回グラフ (DAG)" src="images/image7.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>グラフ</b> - 頂点と、頂点のペアを接続する辺で構成され、頂点はあらゆる種類のオブジェクトを表し、辺はそれらの間の接続を表します。</p>
    <p><b>有向グラフ</b> - 各辺は特定の方向を持ち、ある頂点から別の頂点へ向かいます。有向グラフ内のパスは、ある辺の終点と次の辺の始点が一致する辺のシーケンスです。</p>
    <p><b>有向非巡回グラフ</b> - 1つ以上の辺を含むパスを介して、どの頂点も自分自身に到達できない有向グラフであり、サイクルの不在が保証されます。</p>
    <p>グラフについては学ぶべきことがたくさんありますが、私たちの目的のために、KaspaのBlockDAGは単なる構造であり、辺と頂点で構成され、一方向に接続されており、決してサイクルに陥らない、つまり有向非巡回グラフであることだけを知っていれば十分です。</p>
  </div>

  <h3 class="section-title" id="h.r0onrjvzaye8">ビットコインとKaspa</h3>
  <p><b>ビットコイン</b> - はDAGです。常にブロックチェーンと呼ばれていますが、ビットコインはDAG構造を使用しています。ブロックは頂点であり、その関係は辺です。各ブロックは一方向に接続されており、すべての接続をたどってもサイクルを形成することはなく、常にジェネシスに戻ります。</p>
  <div class="img-container"><img alt="線形DAGとしてのビットコインブロックチェーン構造" src="images/image25.png"></div>
  <p><b>Kaspa</b> - はDAGです。KaspaはDAG構造を使用しています。ブロックは頂点であり、その関係は辺です。各ブロックは一方向に接続されており、すべての接続をたどってもサイクルを形成することなく、常にジェネシスに戻ります。</p>
  <div class="img-container"><img alt="KaspaのBlockDAG構造" src="images/image30.png"></div>
  <p>では、ビットコインとKaspaの両方がDAGを使用している場合、何が違うのでしょうか？ビットコインはブロックが1つの前のブロックのみを指すことを許可します。Kaspaはブロックが複数の前のブロックを指すことを許可します。これが構造上の唯一の違いです。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.q9lxzgpefpuh">第2章：Kaspa - ボディとヘッダーの結合</h2>
  <div class="img-container"><img alt="ブロックヘッダーとブロックボディの結合" src="images/image66.png"></div>
  <h3 class="section-title" id="h.3ezesbjpkjql">ブロックボディをヘッダーに固定する - マークルルート</h3>
  <p>ブロックボディをヘッダーに固定するものは何ですか？ボディ内のトランザクションのマークルルートです。</p>
  <p>それは何を意味するのでしょうか？この章は予備知識を前提としないように設計されているため、まずマークルツリーから始めます。マークルツリーとは何か、どのように構築され、どのように改ざんを防ぐのか。次に、それがビットコインとKaspaの両方にどのように適用されるかを説明します。</p>
  <p><b>マークルツリー</b> - 暗号学およびコンピュータ科学において、マークルツリー（ハッシュツリーとも呼ばれる）は、各「葉」ノードがデータブロックの暗号学的ハッシュを含むツリー状の構造です。非葉ノード（しばしばブランチまたは内部ノードと呼ばれる）は、その子ノードのラベルの暗号学的ハッシュを含みます。この構造により、大規模なデータセットの内容を効率的かつ安全に検証することができます。</p>
  <div class="img-container"><img alt="マークルツリー構造" src="images/image13.png"></div>
  <p><b>データブロック</b> - マークルツリーにおいて、データブロックは、トランザクションのような生のデータの一部であり、ツリー構造の基盤を形成します。各データブロックは個別にハッシュされ、葉ノードハッシュを生成します。</p>
  <div class="img-container"><img alt="データブロック（トランザクション）" src="images/image9.png"></div>
  <p><b>葉</b> - マークルツリー内のノードで、単一のデータブロックの暗号学的ハッシュを格納します。葉ノードは、このハッシュを格納することで、データブロックのデジタル指紋として機能します。</p>
  <div class="img-container"><img alt="トランザクションをハッシュして葉を作成" src="images/image23.png"></div>
  <p><b>内部ノード</b> - 子ノードのハッシュを集約する親ノード。これらの子ハッシュは連結され、ハッシュされて、内部ノードを識別する単一のハッシュ値が生成されます。</p>
  <div class="img-container"><img alt="葉をハッシュして内部ノードを作成" src="images/image58.png"></div>
  <p><b>ハッシュルート</b> - ツリー内のすべてのデータをカプセル化する最上位ノードの単一のハッシュ値。それは、すべての基礎となるデータブロックのコンパクトでユニークな要約として機能します。単一の葉ノードへの変更は、ハッシュルートを変更します。</p>
  <div class="img-container"><img alt="マークルルート、最終ハッシュ" src="images/image5.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>マークルツリー</b> - データブロックを暗号学的ハッシュの構造に整理することで、データの整合性を効率的に検証するために使用されるツリー状の構造。</p>
    <p><b>データブロック</b> - 葉ノードを作成するためにハッシュされる、トランザクションなどの情報の単位。</p>
    <p><b>葉</b> - 単一のデータブロックのハッシュを格納するノード。</p>
    <p><b>内部ノード</b> - 子ノードのハッシュを含む親ノード。</p>
    <p><b>ハッシュルート</b> - データセット全体の整合性を表す単一のハッシュを含む最上位ノード。</p>
  </div>

  <h3 class="section-title" id="h.emrhhaf2640n">ビットコインとKaspa</h3>
  <p><b>ビットコイン</b> - マークルツリーは、各ブロック内のトランザクションデータを整理します。トランザクションは葉ノードにハッシュされ、ペアリングされて内部ノードにハッシュされ、ブロックヘッダーに格納された単一のマークルルートに結合されます。この構造により、トランザクションの整合性を効率的に検証できます。</p>
  <div class="img-container"><img alt="ビットコインにおけるマークルツリー" src="images/image18.png"></div>
  <p><b>Kaspa</b> - マークルツリーは、ビットコインと同じ方法で各ブロック内のトランザクションデータを整理します。しかし、Kaspaは並列ブロックの共存を可能にし、DAG内のこれらのブロック間の順序は不明な場合があります。マークルツリーは順序に依存します。Kaspaはこれをどのように解決するのでしょうか？追加のマークルツリーを追加することで。</p>
  <div class="img-container"><img alt="Kaspaにおけるマークルツリー" src="images/image69.png"></div>
  <p>ブロックボディをヘッダーに固定するものは何ですか？ボディ内のトランザクションのマークルルート（<code>hash_merkle_root</code>）です。</p>
  <p>マージセットトランザクションをヘッダーに固定するものは何ですか？マージセット内のトランザクションのマークルルート（<code>accepted_id_merkle_root</code>）です。この2番目のルートにより、マージされる並列ブロックからのトランザクションの検証が可能になり、DAG環境での順序付けの問題が解決されます。</p>
  <div class="img-container"><img alt="Kaspaのブロックヘッダーにある2つのマークルルート" src="images/image65.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.y0ik307h70q9">第3章：Kaspaと「ビットコインのスケーラビリティ問題」</h2>
  <div class="img-container"><img alt="スケーラビリティ問題の図" src="images/image53.png"></div>
  <h3 class="section-title" id="h.2jy3kmwufuue">Kaspaは「ビットコインのスケーラビリティ問題」を解決した - それは何？</h3>
  <p>ビットコインのスケーラビリティ問題とは何ですか？そしてKaspaはそれをどのように解決したのでしょうか？それは包含によってです。</p>
  <p>それは何を意味するのでしょうか？この章は予備知識を前提としないように設計されているため、まずクライアント-サーバーモデルから始め、次にピアツーピアネットワークについて説明します。P2Pネットワークとは何か、どのようなもので、メッセージがどのように伝播するのか。次に、それがビットコインとKaspaの両方にどのように適用されるかを説明します。</p>
  <p><b>クライアント-サーバーモデル</b> - クライアント-サーバーネットワークでは、集中型アーキテクチャが、サーバーと呼ばれる単一の強力なコンピュータを介して通信とリソース共有を組織し、そのサーバーがクライアントと呼ばれる複数のユーザーデバイスに接続します。この構造は効率的な管理を保証しますが、サーバーに大きく依存するため、脆弱です。</p>
  <div class="img-container"><img alt="クライアント-サーバーモデル" src="images/image67.png"></div>
  <p><b>ピアツーピア（P2P）ネットワーク</b> - 相互接続されたノード間で直接通信とリソース共有を可能にする分散型アーキテクチャ。各ピアはクライアントとサーバーの両方として機能し、中央機関に依存することなくネットワークの回復力とスケーラビリティに貢献します。</p>
  <div class="img-container"><img alt="ピアツーピアネットワーク" src="images/image12.png"></div>
  <p><b>伝播時間</b> - P2Pネットワークにおいて、伝播時間とは、データ（新しいブロックなど）がネットワーク内の1つのノードから他のノードへ伝わるのにかかる時間のことです。この間、異なるノードはネットワークの状態について異なる見方をする可能性があります。</p>
  <div class="img-container"><img alt="P2Pネットワークにおけるメッセージ伝播" src="images/image37.png"></div>
  
  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>クライアント-サーバーモデル</b> - 1台の集中型コンピュータが複数のクライアントのデータを管理します。</p>
    <p><b>ピアツーピア（P2P）</b> - 複数のコンピュータが中央機関なしで直接データを共有します。</p>
    <p><b>ノード</b> - P2Pネットワークに参加する個々のコンピュータ。</p>
    <p><b>伝播時間</b> - データがネットワーク全体に伝播するのにかかる時間。</p>
  </div>

  <h3 class="section-title" id="h.v4bl36mx6e0u">ビットコインとKaspa</h3>
  <p><b>ビットコイン</b> - はP2Pネットワークを使用しています。しかし、そのセキュリティは、ブロック生成率（10分）が伝播時間よりもはるかに遅いことに依存しています。ブロックが速く生成されすぎると、多くのブロックが「孤立」（拒否）され、作業が無駄になり、セキュリティが損なわれます。これが「スケーラビリティ問題」です。</p>
  <div class="img-container"><img alt="ネットワーク遅延によるビットコインの孤立ブロック" src="images/image45.png"></div>
  <p><b>Kaspa</b> - は、複数の以前のブロックを指すことができる包括的なプロトコル（GHOSTDAG）を使用しています。伝播中に並列ブロックが作成された場合、それらはすべてDAGに含まれます。孤立ブロックはありません。これにより、ブロック生成率が伝播時間よりも速くなり、セキュリティを維持しながらスケーラビリティ問題が解決されます。</p>
  <div class="img-container"><img alt="Kaspaにおける並列ブロックの包含" src="images/image14.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.1tq8u5wwr5up">第4章：MuHash</h2>
  <div class="img-container"><img alt="MuHashコンセプトの図" src="images/image35.png"></div>
  <h3 class="section-title" id="h.ny65anmiz0s">MuHashとは何か、Kaspaはどのようにそれを使用しているか？</h3>
  <p>UTXOを追跡し、古いブロックボディデータをプルーニングするための構造。</p>
  <p>それは何を意味するのでしょうか？この章は予備知識を前提としないように設計されているため、まずMuHashから始めます。MuHash構造とは何か、どのように計算され、どのように乗算の特性を保持するのか。次に、それがビットコインとKaspaの両方にどのように適用されるかを説明します。</p>
  <p><b>MuHash</b> - 暗号システムにおいて、MuHash（乗算ハッシュ）は、要素の集合から単一のハッシュ値を効率的に計算するために設計された特殊なハッシュアルゴリズムです。これは増分更新を可能にし、データセット全体を再計算することなく要素を追加または削除できるため、動的なデータセットでのパフォーマンスが向上します。</p>
  <div class="img-container"><img alt="MuHashでの要素の追加と削除" src="images/image57.png"></div>
  <p><b>分子と分母</b> - MuHashは2つのカウンターを使用します。追加された要素を乗算する分子と、削除された要素を乗算する分母です。最終的な状態は、分子を分母で「割る」（モジュラー逆数による乗算）ことで得られます。操作の順序は関係なく、これは並列処理にとって重要です。</p>
  <div class="img-container"><img alt="分子と分母によるMuHash計算" src="images/image2.png"></div>
  <div class="img-container"><img alt="分子と分母によるMuHash計算" src="images/image64.png"></div>
  <p><b>素数モジュロ制約</b> - 素数モジュロは、すべての算術演算中に分子と分母を管理可能な範囲内に保つ数学的境界として機能します。各乗算は素数モジュロで行われるため、要素がいくつ追加または削除されても、結果は常に有限体内に「ラップアラウンド」します。</p>
  <div class="img-container"><img alt="素数モジュロ制約" src="images/image16.png"></div>
  <p><b>モジュラー逆数</b> - モジュラー逆数は、MuHashが使用する有限体で除算を可能にする数学演算です。最終的なハッシュ結果を得るために分子を分母で「割る」必要がある場合、実際には分子に分母のモジュラー逆数を乗算します。</p>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>MuHash</b> - 順序が関係ない集合内の要素を高速にハッシュするための構造。</p>
    <p><b>分子</b> - 要素が追加されたときに乗算されるフィールド。</p>
    <p><b>分母</b> - 要素が削除されたときに乗算されるフィールド。</p>
    <p><b>素数モジュロ制約</b> - すべての操作が行われる数学的フィールドを定義する素数。</p>
    <p><b>モジュラー逆数</b> - 有限体で「除算」を可能にする操作。</p>
    <p>MuHashは、分子と分母からなる単なる構造であり、集合内の要素を任意の順序で、最初から再計算することなく高速にハッシュすることを可能にします。</p>
  </div>

  <h3 class="section-title" id="h.focbph7aurgq">ビットコインとKaspa</h3>
  <p><b>ビットコイン</b> - フルノードは、古い使用済みトランザクションを含むすべてのトランザクションを保持します。プルーニングは困難です。なぜなら、履歴データを保持せずにトランザクションの状態（UTXOセット）をコンパクトかつ検証可能に要約する効率的なメカニズムがないからです。</p>
  <div class="img-container"><img alt="ビットコインブロックチェーンの完全ストレージ" src="images/image42.png"></div>
  <p><b>Kaspa</b> - フルノードは古いデータをプルーニングします。古いデータをプルーニングするこの能力は、各ブロックからすべてのトランザクションデータを削除し、それを各ヘッダーに暗号学的に固定する方法を必要とします。KaspaはMuHashを使用して、ブロックからトランザクションデータを削除し（プルーニングポイント以降はDAGヘッダーのみが残るように）、それを各ヘッダーに固定します。これはプルーニングにとって不可欠なステップです。Kaspaはトランザクションデータ（UTXO）とコンセンサスデータ（ヘッダー）を分離しており、これはKaspaが、これまで行われたすべてのトランザクションではなく、未使用のトランザクションのみを保存することを意味します。これにより、ビットコインと比較してストレージ要件が削減されます。</p>
  <div class="img-container"><img alt="MuHashによるKaspaのプルーニング済みストレージ" src="images/image51.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.oy0kgniero14">第5章：KaspaのUTXOモデル</h2>
  <div class="img-container"><img alt="UTXOモデルの図" src="images/image74.png"></div>
  <h3 class="section-title" id="h.8nqvw067oam1">UTXOとは何か、Kaspaはどのようにそれを使用しているか？</h3>
  <p>誰がどのKaspaを使うことができるかを追跡するための構造。</p>
  <p>それは何を意味するのでしょうか？この章は予備知識を前提としないように設計されているため、まずアカウントモデルとUTXOモデルから始め、次にUTXOとは何か、何を含み、どのように使用されるのかを説明します。次に、それがビットコインとKaspaの両方にどのように適用されるかを説明します。</p>
  <p><b>アカウントモデル</b> - アカウントモデルは、残高を維持し、おなじみの操作を提供する従来の銀行口座のように機能します。銀行の残高を確認するのと同じように、アカウントの現在の保有残高を照会でき、銀行が取引履歴を追跡するのと同様に、アカウントはあなたの財務状況を管理します。システムは、預金の受け取りや送金などの標準的なアカウント操作を提供し、各アカウントには簡単な管理のために独自の識別子と名前があります。銀行がさまざまな目的のためにさまざまなタイプのアカウントを提供するのと同様に、さまざまなニーズを満たすためにさまざまなタイプのアカウントが利用可能です。</p>
  <div class="img-container"><img alt="アカウントモデル" src="images/image52.png"></div>
  <p><b>UTXOモデル</b> - UTXOモデルは、あなたの財布にある物理的な現金や硬貨のように機能します。各硬貨には特定の価値があり、一度だけ使うことができます。物理的な財布に様々な額面の紙幣や硬貨があるように、デジタルウォレットには様々な金額のUTXOが複数含まれており、それがあなたの使える残高を表します。取引を行う際、特定のUTXOが入力として消費され（まるで正確な紙幣を使うように）、受信者への出力として、またあなたに戻るお釣りとして新しいUTXOが作成されます。これは、大きな紙幣で支払ったときにレジ係がお釣りを出してくれるのと似ています。システムは、これらの個々の「硬貨」をすべての取引にわたって追跡し、どのUTXOが存在し、使うことができるかの完全な記録を保持します。これは、物理的なお金がその個々のアイデンティティを保ちながら人から人へと移動するのと同様です。</p>
  <div class="img-container"><img alt="UTXOモデル" src="images/image22.png"></div>
  <p><b>UTXO構造</b> - UTXO（未使用トランザクション出力）は、小切手が金額、受取人詳細、承認情報を含むのと同様に、使用するために必要なすべての重要な情報を含むデジタルレシートとして構造化されています。各UTXOは、それが保持する価値を含み、使用条件を定義します。物理的な硬貨がその額面を刻印され、本物として検証できるのと同様に、各UTXOはその価値と暗号学的所有権の証明を運び、独立して検証および使用できる自己完結型の価値単位となります。システムは各UTXOを独自の識別子を持つ独立したオブジェクトとして扱い、ネットワーク内を移動する個々の価値単位を正確に追跡できます。</p>
  <div class="img-container"><img alt="UTXOの構造" src="images/image17.png"></div>
  <p><b>UTXOを使う</b> - UTXOを使うことは、物理的な現金を使うことと似ています。購入するには正確な紙幣や硬貨を提示する必要があり、一度使ったら再利用できません。プロセスは、使いたい特定のUTXOを見つけ、UTXOセット内に存在することを確認することから始まります。これは、財布の中の紙幣が本物で未使用であることを確認するのと似ています。トランザクションを作成する際、その一意の識別子でUTXOを参照し、それを使う権利があることを証明する署名スクリプトを提供します。システムは、UTXOがまだ使われていないこと（二重支払いを防ぐ）、あなたが使う条件を満たしていることを検証し、その後、UTXOを使用可能なセットから削除し、受信者への出力として、またあなたに戻るお釣りとして新しいUTXOを作成し、一方から他方への価値の移転を完了します。</p>
  <div class="img-container"><img alt="UTXOを使うプロセス" src="images/image31.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>アカウントモデル</b> - アカウントごとに単一の残高を管理するシステム。</p>
    <p><b>UTXOモデル</b> - 価値の個々の「コイン」を追跡するシステム。</p>
    <p><b>UTXO</b> - 特定の金額を表す未使用のトランザクション出力。</p>
    <p><b>UTXOを使う</b> - 新しいUTXOを作成するためにUTXOを消費するプロセス。</p>
    <p>UTXOは、誰が何を使うことができるかを追跡するための単なる構造です。</p>
  </div>

  <h3 class="section-title" id="h.5v09d76siagw">ビットコインとKaspa</h3>
  <p><b>ビットコイン</b> - はUTXOモデルを使用しています。トランザクションは、各ブロックのボディに格納された、消費されたUTXOと作成されたUTXOの集合です。</p>
  <div class="img-container"><img alt="ビットコインにおけるUTXOモデル" src="images/image27.png"></div>
  <p><b>Kaspa</b> - もUTXOモデルを使用しています。主な違いは、BlockDAG環境でこれらのUTXOがどのように管理および検証されるかであり、これにより並列処理と高速な確認が可能になります。</p>
  <div class="img-container"><img alt="KaspaにおけるUTXOモデル" src="images/image44.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.6x07cz5zmxim">第6章：親ブロックとマージセット</h2>
  <div class="img-container"><img alt="DAGにおけるブロック間の関係" src="images/image4.png"></div>
  <h3 class="section-title" id="h.34xcaoqpznos">親ブロックとマージセットとは何か、Kaspaはどのようにそれらを使用しているか？</h3>
  <p>KaspaのBlockDAG構造におけるブロック間の関係を記述する2つの異なる方法。</p>
  <p><b>伝統的なブロックチェーンの親ブロック</b> - ビットコインのような線形ブロックチェーンでは、各ブロックには（ジェネシスを除く）正確に1つの親ブロックがあり、単純なチェーン構造を形成します。親子の関係は単純です。各新しいブロックは前のブロックのハッシュを参照し、ジェネシスから現在の先端まで途切れないシーケンスを形成します。</p>
  <div class="img-container"><img alt="ビットコインにおける親子関係" src="images/image34.png"></div>
  <p><b>DAGの親ブロックの複雑性</b> - KaspaのBlockDAGは、ブロックが複数の親を持つことを可能にし、より複雑な関係のネットワークを作成します。ブロックが作成されると、既存の複数のブロックを親として参照でき、これにより並列ブロックの作成と高いスループットが可能になります。</p>
  <div class="img-container"><img alt="Kaspaにおける複数の親子関係" src="images/image36.png"></div>
  <p><b>親ブロック</b> - 親ブロックとは、新しいブロックがそのヘッダー内で直接参照するブロックのことです。これらはブロック作成者によって宣言される明示的な関係であり、新しいブロックが直接構築される基盤となるブロックです。Kaspa DAGビジュアライザーを見ると、これらの矢印が親ブロックの関係を表しています。</p>
  <div class="img-container"><img alt="新しいブロックがその親ブロックを指している" src="images/image11.png"></div>
  <p><b>親ブロックの仕組み</b> - ブロックを作成する際、マイナーはDAGの現在の「先端」と見なすものに基づいて、既存のブロックを親として参照するように選択します。システムはこれらの親子関係を検証し、それらを使用してDAG構造内のブロックの位置を決定します。ここでは、新しいブロックが作成され、DAGの「先端」、つまり他のブロックが指していないブロックを参照している様子を見ることができます。</p>
  <div class="img-container"><img alt="新しいブロックの作成と先端の選択" src="images/image56.png"></div>
  <p><b>マージセット</b> - マージセットとは、ブロックの選択された親ブロックのアンチコーン内にありながら、ブロックのコンセンサスコンテキストの一部と見なされるブロックの集合です。ここでは、ブロックCはBのアンチコーン内にあり、ブロックBはCのアンチコーン内にあります。</p>
  <div class="img-container"><img alt="ブロックのマージセットの図" src="images/image29.png"></div>
  <p><b>マージセットの計算方法</b> - マージセットは、選択された親ブロックの祖先ではないが、ブロックの親ブロックのセットを介して到達可能なすべてのブロックを見つけることによって計算されます。これにより、コンセンサス決定のために考慮する必要があるブロックのより広いコンテキストが作成されます。この例では、ブロックBが選択された親ブロックである場合、作成されるブロックのマージセットにはブロックCとブロックDの両方が含まれます。</p>
  <div class="img-container"><img alt="マージセットの計算" src="images/image47.png"></div>
  <p><b>GHOSTDAGにおけるマージセット</b> - GHOSTDAGプロトコルは、マージセットを処理して、どのブロックを「青」（コンセンサスに貢献）または「赤」（有効だが貢献しない）に色付けするかを決定します。この色付けプロセスは、並列ブロック環境でコンセンサスを維持するために不可欠です。</p>

  <h3 class="section-title">親ブロックとマージセットの連携</h3>
  <p><b>選択された親ブロックの選択</b> - すべての親ブロックの中から、システムは「選択された親ブロック」として1つを選択します。これは、「青い作業量」が最も多い親ブロックです。これにより、DAGを通じてメインチェーンのバックボーンが作成され、同時に他の親ブロックの関係も認識されます。ここでは、親チェーンが強調表示されています。</p>
  <div class="img-container"><img alt="選択された親ブロックの選択とメインチェーン" src="images/image75.png"></div>
  <p><b>マージセットの処理</b> - 選択された親ブロックが選択されると、マージセットが計算され、最終的なGHOSTDAGデータを決定するために処理されます。マージセットは選択された親ブロックを除外します。なぜなら、それはすでにメインチェーンに計上されているからです。ここでは、ブロックCはブロックB（選択された親ブロック）のアンチコーン内にあるため、マージセットに含まれています。ブロックCは新しいブロックの親ブロックではありませんが（親ブロックにはブロックBとブロックDのみが含まれます）。</p>
  <div class="img-container"><img alt="マージセットの処理" src="images/image26.png"></div>
  <p><b>仮想親ブロックの選択</b> - 仮想状態を作成する際、システムは両方の概念を使用します。候補ブロックから仮想親ブロックを選択し、同時に結果のマージセットがサイズ制限を超えないようにします。これにより、多くの並列ブロックの包含と、管理可能なコンセンサスの複雑さの維持が両立します。</p>

  <h3 class="section-title">実用的な違い</h3>
  <p><b>ストレージとイテレーション</b> - 親ブロックはブロックヘッダーに直接格納されますが、マージセットデータはGHOSTDAGデータ構造に個別に計算され格納されます。システムは、さまざまな順序（コンセンサス順序、「青い作業」順序など）でマージセットブロックにアクセスするためのさまざまなイテレーターを提供します。</p>
  <p><b>コンセンサスへの影響</b> - 親ブロックはDAGの基本的な構造を決定しますが、マージセットは「青いスコア」や「青い作業」などのコンセンサス計算に実際に貢献するブロックを決定します。ブロックは親ブロックである可能性がありますが、マージセットで赤く色付けされる可能性があり、これはメインのコンセンサスチェーンに貢献しないことを意味します。</p>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>親ブロック</b> - 新しいブロックがそのヘッダー内で直接参照するブロックであり、DAG内で明示的な関係を確立します。</p>
    <p><b>マージセット</b> - ブロックのアンチコーン内のブロックの集合であり、コンセンサス処理の対象となりますが、選択された親ブロックは除外されます。</p>
    <p><b>選択された親ブロック</b> - 最も「青い作業量」が多い親ブロックであり、メインチェーンのバックボーンを形成します。</p>
    <p><b>青/赤のマージセット</b> - マージセット内のブロックで、コンセンサスに貢献する（青）か、貢献しない（赤）かを示します。</p>
    <p>親ブロックはDAGの構造を定義し、マージセットはコンセンサスへの参加を決定します。</p>
  </div>

  <h3 class="section-title" id="h.tsab66lazd4a">ビットコイン対Kaspa</h3>
  <p><b>ビットコイン</b> - 各ブロックには（ジェネシスを除く）1つの親ブロックしかありません。したがって、親ブロックとマージセットの区別はありません。単一の親ブロックは、構造的関係とコンセンサス関係の両方です。</p>
  <div class="img-container"><img alt="シンプルなビットコイン構造" src="images/image55.png"></div>
  <p><b>Kaspa</b> - 構造的関係（親ブロック）とコンセンサス関係（マージセット）を分離します。複数の親ブロックがDAG構造を作成しますが、マージセットの処理によって、どのブロックが実際にコンセンサス状態に貢献するかが決定されます。</p>
  <div class="img-container"><img alt="親ブロックとマージセットを持つKaspaの複雑な構造" src="images/image24.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.x0nj4tecoh66">第7章：二次プルーニング</h2>
  <div class="img-container"><img alt="二次プルーニングの図" src="images/image48.png"></div>
  <h3 class="section-title" id="h.1wbq42gt63wc">二次プルーニングとは何か、Kaspaはどのようにそれを使用しているか？</h3>
  <p>二次プルーニングは、Kaspaのストレージ最適化における高度なステップであり、コンセンサス関連のデータを削除しつつ、新しいブロックを検証し、ネットワークコンセンサスに参加する能力を維持します。これは、DAG構造データ、関係、および一部のヘッダー自体を選択的に削除することで、一次プルーニングを超えています。</p>
  <p>なぜ「二次」なのか？ - この用語は、ブロックボディの削除（一次）が始まりに過ぎないことを強調しています。一次プルーニングはストレージ要件を大幅に削減し、ノード実行の障壁を低くしますが（分散化を向上させます）、さらに多くのデータを削除できる追加のプルーニングステップ（二次プルーニング）が続きます。この章は、特にブロックボディの削除、つまり後続のすべての最適化を可能にする基盤に焦点を当てています。</p>
  <p>それは何を意味するのでしょうか？ - 本章は一次プルーニングに関する知識を前提としているため、まず一次プルーニング後に存在するコンセンサスデータから始め、次に二次プルーニングがコンセンサス構造を選択的に削除する方法、何が保持され何が削除されるか、そして削減されたコンセンサスデータで検証がどのように機能し続けるかを説明します。</p>

  <h3 class="section-title">一次プルーニング対二次プルーニング</h3>
  <p><b>一次プルーニングの基礎</b> - 一次プルーニング後、ノードはすべてのブロックヘッダー、GHOSTDAGデータ、アクセス可能性関係、およびDAG構造情報を保持します。これにより、完全なコンセンサス検証が可能になりますが、Kaspaが維持する複雑なDAG関係には依然としてかなりのストレージが必要です。</p>
  <p><b>二次プルーニングの課題</b> - 課題は、ノードが新しいブロックを検証する能力を損なうことなく、どのコンセンサスデータを安全に削除できるかを決定することです。システムは、冗長なデータを削除しながら、コンセンサスを維持するために十分な構造情報を保持する必要があります。</p>

  <h3 class="section-title">多段階証明システム</h3>
  <p><b>証明レベルの分類</b> - Kaspaのプルーニングシステムは、ブロックを異なる証明レベルに対する重要度に基づいて分類します。より高い証明レベルに属するブロックは、より低いレベルにのみ必要なブロックよりも多くのコンセンサスデータを保持します。</p>
  <p><b>レベルベースのデータ保持</b> - システムは、各ブロックが属する証明レベルに基づいて、どのコンセンサスデータを保持するかを決定します。高レベルのブロックはより多くの関係とコンセンサス情報を保持しますが、低レベルのブロックはコンセンサスデータを安全に削除できます。</p>
  <p><b>連続したDAGゾーン</b> - プルーニングは、各レベルにおいて、残りの関係が連続したDAGゾーンを表すことを保証し、コンセンサス検証に必要な構造的整合性を維持します。</p>

  <h3 class="section-title">二次プルーニングで削除されるもの</h3>
  <p><b>関係データの削除</b> - 二次プルーニングは、より高い証明レベルにのみ属するブロックのレベル固有の関係データを削除します。これにより、関係が連続したDAGゾーンを表すというセマンティクスが保持され、同時に不要な低レベルデータが削除されます。</p>
  <p><b>GHOSTDAGデータの選択的削除</b> - システムは、一部のブロックのGHOSTDAGデータを削除しますが、重要なコンセンサス検証のためにそれらを保持します。部分的にプルーニングされたブロックの場合、GHOSTDAGデータはレベル0で削除されます。</p>
  <p><b>ヘッダーの削除</b> - 最も積極的な二次プルーニングの形式では、一部のブロックヘッダー自体が削除される可能性がありますが、過去のプルーニングポイントは保持されます。プルーニングポイントクエリに不要なヘッダーのみが削除されます。</p>

  <h3 class="section-title">二次プルーニングで保持されるもの</h3>
  <p><b>基本的なコンセンサス構造</b> - プルーニングポイントのアンチコーン、DAAウィンドウブロック、および重要な検証のためのGHOSTDAGブロックなどの重要なコンセンサスデータは常に保持されます。これにより、データストレージが削減されてもコンセンサス操作を継続できます。</p>
  <p><b>証明レベルの所属</b> - ブロックは、証明レベルの重要度に基づいて分類を保持し、どのデータが保持されるかを決定します。システムは、これらの所属に基づいてコンセンサス検証に必要な最小限のデータを保持します。</p>
  <p><b>過去のプルーニングポイント</b> - 過去のプルーニングポイントのヘッダーは、プルーニングポイントクエリに応答し、プルーニング証明システムをサポートする能力を維持するために常に保持されます。</p>

  <h3 class="section-title">コンセンサス検証の継続方法</h3>
  <p><b>状態遷移</b> - 二次プルーニングを受けるブロックは、有効な状態を持ち、証明レベルに属する場合、「ヘッダーのみ」の状態に移行します。これにより、有効な状態が本質的なコンセンサスデータの存在を意味するというセマンティクスが保持されます。</p>
  <p><b>削減されたデータの検証</b> - 二次プルーニングが行われても、ノードは保存されたコンセンサスデータ構造と残りの関係を使用して新しいブロックを検証できます。システムは、GHOSTDAGルールとブロック間の関係を検証するのに十分な情報を保持しています。</p>
  <p><b>証明ベースの検証</b> - 保存された証明レベルのデータにより、ノードは完全な履歴コンセンサスデータではなく暗号学的証明を使用してブロックを検証でき、ストレージを大幅に削減しながらコンセンサスに参加できます。</p>

  <h3 class="section-title">アーカイブノード対プルーニングノード</h3>
  <p><b>アーカイブノードの動作</b> - アーカイブとして設定されたノードは、一次および二次プルーニングを完全に無視し、すべてのコンセンサスデータを保持します。これらのノードはネットワークの完全なコンセンサス台帳として機能しますが、最大のストレージを必要とします。</p>
  <p><b>プルーニングノードの効率</b> - 通常のプルーニングノードは、二次プルーニングを利用して最大のストレージ効率を達成しつつ、多段階証明システムを通じて完全なコンセンサス検証能力を維持します。</p>
  <p>注：プルーニングノードがどのようにフルノードであり続けるか、およびアーカイブノードがネットワーク運用にオプションである理由（ビットコインのトラストレスモデルを維持しながら）の詳細な説明については、検証能力、暗号学的証明、およびネットワークの持続可能性を扱う拡張記事「アーカイブノード対フルノード」を参照してください。</p>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>二次プルーニング</b> - コンセンサス関連のデータを削除しつつ、コンセンサスルールを検証するのに十分な情報を保持すること。</p>
    <p><b>証明レベルの所属</b> - ブロックを所属する証明レベルに基づいて分類し、どのコンセンサスデータを保持するかを決定すること。</p>
    <p><b>「ヘッダーのみ」の状態</b> - コンセンサスデータがプルーニングされたが、本質的な検証情報を保持しているブロック。</p>
    <p><b>連続したDAGゾーン</b> - プルーニング後も残りのコンセンサスデータにおける構造的整合性を維持すること。</p>
    <p>二次プルーニングは、インテリジェントなデータ分類により、コンセンサス検証能力を維持しながら最大のストレージ効率を可能にします。</p>
  </div>

  <h3 class="section-title">ビットコイン対Kaspa：コンセンサスデータのプルーニング</h3>
  <p><b>ビットコイン</b> - コンセンサス情報は検証に不可欠であり、安全に削除することはできません。</p>
  <p><b>Kaspa</b> - 複雑なDAG構造と多段階証明システムにより、洗練された二次プルーニングが可能になります。これにより、コンセンサスデータのさまざまなレベルを、検証に対する重要度に基づいて選択的に削除できます。これにより、コンセンサス機能を維持しながら、ストレージ最適化をはるかに積極的に行うことができます。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.mz2dlkhrvwd2">第8章：Kaspa GHOSTDAGの簡略化</h2>
  <div class="img-container"><img alt="GHOSTDAGの図" src="images/image43.png"></div>
  <h3 class="section-title" id="h.hwkbrs8egi6p">GHOSTDAGとは何か、Kaspaはどのようにそれを使用しているか？</h3>
  <p>DAG構造でブロックを順序付けし、セキュリティ特性を維持するコンセンサスプロトコル。</p>
  <p>それは何を意味するのでしょうか？この章では、従来のコンセンサスから始めてGHOSTDAGを説明し、次にGHOSTDAGのアプローチ、ブロックの分類方法、そしてビットコインとKaspaの違いを説明します。</p>

  <h3 class="section-title">従来のコンセンサス - 線形チェーンの順序付け</h3>
  <p>従来のブロックチェーンのコンセンサスは、ブロックが単一のシーケンスを形成する線形チェーンで動作します。各ブロックには（ジェネシスを除いて）正確に1つの親ブロックがあり、単純な順序付けメカニズムが作成されます。競合が発生した場合（同じ高さに複数のブロックがある場合）、ネットワークは1つのブロックを選択し、他のブロックを孤立ブロックとして拒否します。このアプローチは明確な順序付けを保証しますが、各レベルで1つのブロックしか受け入れられないため、スループットが制限されます。</p>
  <div class="img-container"><img alt="従来のコンセンサス" src="images/image32.png"></div>

  <h3 class="section-title">GHOSTDAGプロトコル - DAGコンセンサス</h3>
  <p>GHOSTDAGは、ブロックが複数の親を持つことができる有向非巡回グラフ（DAG）構造で動作するようにコンセンサスを拡張します。このプロトコルは、まず最も「青い作業量」を持つ親ブロックを選択し、次にマージセット内のすべてのブロックを調べて、「青」（正直）または「赤」（潜在的に競合）に分類します。この分類は、セキュリティパラメータKを含む数学的制約に基づいており、セキュリティ特性を維持するためにアンチコーンのサイズを制限します。</p>
  <div class="img-container"><img alt="GHOSTDAGプロトコル" src="images/image40.png"></div>

  <h3 class="section-title">ブロック分類ルール</h3>
  <p>GHOSTDAGは、セキュリティパラメータKに関連する2つの主要な制約を使用してブロックを分類します。まず、候補ブロックのアンチコーン内の青いブロックの数は、Kブロックを超えてはなりません。次に、既存の各青いブロックについて、候補を追加しても、どの青いブロックのアンチコーンもKブロックを超えてはなりません。アルゴリズムは、ブロック処理中にこれらの制約を効率的に検証するために、アンチコーンのサイズを追跡します。ここで灰色のブロックは現在ネットワークによって検証されており、ブロックCはその選択された親ブロックです。k=0の場合、チェーンブロックCはすでに1つの青いブロックであり、ブロックBは赤に分類されます。k=1（またはそれ以上）の場合、ブロックBは青に分類されます。なぜなら、そのアンチコーンには1つの青いブロック（ブロックC）しかないからです。</p>
  <div class="img-container"><img alt="ブロック分類ルール" src="images/image28.png"></div>

  <h3 class="section-title">青い作業量の蓄積</h3>
  <p>このプロトコルは、青いブロックからのみ作業量証明を蓄積し、「青い作業量」という指標を作成します。青いブロックはその計算作業量を累積セキュリティスコアに貢献しますが、赤いブロックはこの計算から除外されます。この選択的な蓄積により、コンセンサスが有効なブロックのみがネットワークセキュリティに貢献し、悪意のあるブロックや競合するブロックがシステムを弱体化させるのを防ぎます。この例では、ブロックBが赤（k=0）であると仮定すると、灰色のブロックの「青い作業量」は、ブロックCから継承された「青い作業量」にブロックCの「青い作業量」を加算して計算されます。ブロックBが青い場合、新しいブロックの「青い作業量」は、選択された親ブロック（ブロックC）の「青い作業量」を継承し、次に選択された親ブロック（C）の「青い作業量」と、そのマージセット（ブロックB）内の青いブロックの「青い作業量」を加算します。</p>
  <div class="img-container"><img alt="青い作業量の蓄積" src="images/image62.png"></div>

  <h3 class="section-title">親ブロックの選択と順序付け</h3>
  <p>GHOSTDAGは、「青い作業量」の値に基づいて親ブロックを選択することで、ブロックの順序を決定します。このプロトコルは、最も高い累積「青い作業量」を持つ親ブロックを「選択された親ブロック」として選択し、DAG構造内にバックボーンチェーンを作成します。ブロックの順序は「青い作業量」を主要な基準として使用し、ブロックヘッダーのハッシュは同点の場合に決定論的な順序を提供します。この例では、ブロックCが選択された親ブロックであり、ブロックBが青いと仮定します。トランザクション処理の順序は、1. 選択された親ブロック（C）、2. 順序付けられたマージセット（B）です。</p>
  <div class="img-container"><img alt="親ブロックの選択と順序付け" src="images/image6.png"></div>

  <h3 class="section-title">データストレージと管理</h3>
  <p>プロトコルは、分類結果を、青いブロックと赤いブロックのリストを含む構造化データに保存します。青いブロックは、将来の分類決定のためにアンチコーンのサイズ追跡とともに追加され、赤いブロックは単に赤いリストに追加されます。この組織は、DAGの完全な情報を維持しながら、コンセンサスロールを明確に区別します。</p>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>従来のコンセンサス</b> - ブロックが単一のシーケンスを形成し、ブロックごとに1つの親ブロックを持つ線形チェーン順序付けシステム。</p>
    <p><b>GHOSTDAGプロトコル</b> - アンチコーンのサイズ制約に基づいてブロックを青または赤に分類するDAGコンセンサスメカニズム。</p>
    <p><b>ブロック分類</b> - ブロックが青（コンセンサス有効）か赤（潜在的に競合）かを判断するプロセス。</p>
    <p><b>青い作業量の蓄積</b> - 青いブロックからの作業量のみを含む作業量証明の選択的カウント。</p>
    <p>GHOSTDAGは、ブロックチェーンのセキュリティ特性を維持しながら、DAG構造を可能にするコンセンサスプロトコルです。</p>
  </div>

  <h3 class="section-title">ビットコインとKaspa</h3>
  <p><b>ビットコイン</b> - は、ブロックが単一のシーケンスを形成する従来の線形チェーンコンセンサスを使用しています。競合するブロックは孤立し、セキュリティに貢献しません。最長チェーン（最も多くの累積作業量）が、単純な比較メカニズムによってコンセンサスを決定します。</p>
  <div class="img-container"><img alt="ビットコインとGHOSTDAG" src="images/image71.png"></div>
  <p><b>Kaspa</b> - は、複数の同時ブロックを持つDAG構造を管理するためにGHOSTDAGプロトコルを使用しています。青いブロックは「青い作業量」の蓄積を通じてセキュリティに貢献しますが、赤いブロックはDAGに残りますが、コンセンサス決定からは除外されます。このプロトコルは、ネットワークの状態を包括的に追跡するために両方のタイプのブロックを保持します。</p>
  <div class="img-container"><img alt="KaspaとGHOSTDAG" src="images/image19.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.drxg3f8wwuwc">第9章：DAG用語</h2>
  <div class="img-container"><img alt="DAG用語" src="images/image8.png"></div>
  <h3 class="section-title">過去、未来、アンチコーン、マージセット、Kパラメータ、これらすべては何を意味するのか？</h3>
  <p>過去、未来、アンチコーンはDAG用語であり、マージセットとKはGHOSTDAGで使用されます。</p>
  <p>DAG用語は、BlockDAG構造における関係を記述するための専門用語です。まず線形チェーン、DAG、そしてGHOSTDAGについて軽く触れます。</p>

  <h3 class="section-title">線形チェーン用語 - 従来のブロックチェーン</h3>
  <p>線形チェーン用語は、ブロックが単一のシーケンスを形成する単純な概念を使用します。各ブロックには親ブロックと、場合によっては子ブロックがあり、単純な祖先-子孫関係が作成されます。高さ、前のブロック、次のブロックなどの用語は、線形的な進行を記述します。競合が発生した場合、ブロックはメインチェーンに「受け入れられる」か、「孤立」して破棄されます。</p>
  <div class="img-container"><img alt="線形チェーン用語" src="images/image15.png"></div>

  <h3 class="section-title">DAG用語</h3>
  <p>ブロックが複数の親を持つことを許可すると、DAG内に新しい関係が生まれます。</p>
  <div class="img-container"><img alt="DAG用語" src="images/image50.png"></div>

  <h3 class="section-title">過去と未来の関係 - DAG</h3>
  <p>過去の関係は、与えられたブロックから親リンクをたどって遡ることができるすべてのブロックを定義します。あるブロックが別のブロックの過去にあるのは、それらを接続する有向パスが存在する場合です。未来の関係は逆の働きをします。もしブロックAがブロックBの過去にあるなら、ブロックBはブロックAの未来にあります。</p>
  <div class="img-container"><img alt="過去と未来の関係 - DAG" src="images/image73.png"></div>

  <h3 class="section-title">アンチコーン関係 - DAG</h3>
  <p>アンチコーンは、互いの祖先でも子孫でもないブロックを記述します。それらはDAG内に同時に存在します。2つのブロックが互いのアンチコーンにあるのは、どちらのブロックも有向パスを介してもう一方に到達できない場合です。この関係は、GHOSTDAGのセキュリティパラメータKにとって重要であり、コンセンサスセキュリティを維持するためにアンチコーンのサイズを制限します。ここでは、ブロックBとブロックCは互いのアンチコーン内にあり、ブロックBはブロックCから到達できず、ブロックCはブロックBから到達できません。</p>
  <div class="img-container"><img alt="アンチコーン関係 - DAG" src="images/image59.png"></div>

  <h3 class="section-title">マージセットと青/赤の分類 - GHOSTDAG</h3>
  <p>マージセットとは、新しいブロックが作成される際にマージされるブロックの集合を指します。マージセットにはブロックの直接の親ブロックが含まれますが、直接の親ブロックではないブロックも含まれる場合があります。GHOSTDAGは、アンチコーンのサイズ制約に基づいて、マージセット内のブロックを「青」（正直）または「赤」（潜在的に競合）に分類します。この分類は、「青い作業量」の蓄積を通じてどのブロックがネットワークセキュリティに貢献するかを決定します。以下は、アンチコーンのサイズ制約が0の場合に、ブロックBがマージセットを青と赤に分類する例です。</p>
  <div class="img-container"><img alt="マージセットと青/赤の分類 - GHOSTDAG" src="images/image46.png"></div>

  <h3 class="section-title">Kパラメータ - GHOSTDAG</h3>
  <p>Kパラメータは、青いブロックのアンチコーンの最大許容サイズを制御します。このパラメータは、ネットワーク遅延、ブロック生成率、および望ましいセキュリティ保証に基づいて計算されます。この例では、上記の例のようにk=0ではなくk=1であるため、各青いブロックはアンチコーン内にさらに1つの青いブロックを持ちます。</p>
  <div class="img-container"><img alt="Kパラメータ - GHOSTDAG" src="images/image61.png"></div>

  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>過去の関係</b> - 与えられたブロックから親リンクをたどって遡ることができるすべてのブロック。</p>
    <p><b>未来の関係</b> - 親リンクをたどって進むことで、与えられたブロックに到達できるすべてのブロック。</p>
    <p><b>アンチコーン関係</b> - 互いの祖先でも子孫でもないブロック。</p>
    <p><b>マージセット</b> - 新しいブロックが作成される際にマージされるGHOSTDAGブロックの集合。</p>
    <p><b>青/赤の分類</b> - GHOSTDAGによるブロックの分類で、正直（青）または潜在的に競合（赤）のいずれか。</p>
    <p><b>セキュリティパラメータK</b> - コンセンサスセキュリティを維持するためのGHOSTDAGのアンチコーンの最大許容サイズ。</p>
  </div>

  <h3 class="section-title">ビットコインとKaspa</h3>
  <p><b>ビットコイン</b> - は、シンプルな線形用語を使用しています。「前のブロック」、「次のブロック」、「チェーンの高さ」、「最長チェーン」です。関係は単純な祖先-子孫のつながりです。競合するブロックは、中間状態なしに「孤立」します。</p>
  <div class="img-container"><img alt="ビットコインと用語" src="images/image54.png"></div>
  <p><b>Kaspa</b> - は、DAGの過去/未来/アンチコーン関係、GHOSTDAGのマージセット、マージセットの青/赤分類などの追加用語を使用しています。Kaspaは複数の同時ブロックを維持し、それらの関係を管理し、一貫した順序を提供します。</p>
  <div class="img-container"><img alt="Kaspaと用語" src="images/image49.png"></div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.1uals18cttyl">第10章：一次プルーニング</h2>
  <div class="img-container"><img alt="一次プルーニングの図" src="images/image41.png"></div>
  <h3 class="section-title" id="h.3i8fyh1jrh8m">一次プルーニングとは何か、Kaspaはどのようにそれを使用しているか？</h3>
  <p>一次プルーニングは、Kaspaの多段階ストレージ最適化の最初のステップです。これは、古いトランザクションデータをブロックから削除しつつ、プルーニングポイントでUTXOセットを保持して状態検証を行うものです。しかし、重要なのは、ブロックチェーンの整合性を維持するためにすべてのブロックヘッダーが保持されることです。</p>
  <p>なぜ「一次」なのか？ - この用語は、ブロックボディの削除が始まりに過ぎないことを強調しています。一次プルーニングはストレージ要件を大幅に削減し、ノードの実行障壁を低くしますが（分散化を向上させます）、さらに多くのデータを削除できる追加のプルーニングステップ（二次プルーニング）が続きます。この章は、特にブロックボディの削除、つまり後続のすべての最適化を可能にする基盤に焦点を当てています。</p>
  <p>それは何を意味するのでしょうか？ - この章は予備知識を前提としないため、まず従来のブロックチェーンストレージの課題から始め、次に一次プルーニングがUTXOセットを維持することでどのように機能するか、何が削除され何が保持されるか、プルーニングポイントのUTXOセットがどのように検証を可能にするか、そしてこれがKaspaのスケーラブルなストレージモデルの基盤をどのように作成し、より広範なネットワーク参加を可能にするかを説明します。</p>

  <h3 class="section-title">従来のストレージ対一次プルーニング</h3>
  <p><b>従来の完全ストレージ</b> - 従来のブロックチェーン実装では、ノードはジェネシスから現在の先端までのすべてのトランザクション詳細を含む完全なブロックデータを保存します。これは、すべての入力、出力、署名、およびトランザクションスクリプトが永久に保存されることを意味し、多くのユーザーにとって法外なものとなる可能性のあるストレージ要件が絶えず増加します。</p>
  <p><b>一次プルーニングの課題</b> - 課題は、古いトランザクションデータを削除しつつ、新しいトランザクションを検証できることです。新しいトランザクションは以前の出力（UTXO）を参照する必要があるため、システムは古いブロックボディがプルーニングされた後でも、これらの参照を検証するのに十分な情報を維持する必要があります。</p>

  <h3 class="section-title">UTXOセットを基盤として</h3>
  <p><b>UTXOセットの定義</b> - UTXOセットは、ブロックチェーン内の特定の時点におけるすべての未使用トランザクション出力を表します。これは、その時点で存在し、使用可能なすべての「コイン」のスナップショットであり、流通しているすべての資金の在庫に似ています。</p>
  <p><b>プルーニングポイントUTXOセット</b> - Kaspaは、検証の基本状態として機能する特別なUTXOセットをプルーニングポイントで維持します。このUTXOセットは、プルーニングポイントが進むにつれて更新され、常にそのチェックポイントで正しい使用可能な状態を反映するようにします。</p>
  <p><b>UTXOセットの進行</b> - プルーニングポイントが進むにつれて、システムはチェーン内のブロックからのUTXO差分を適用して、プルーニングポイントのUTXOセットを更新します。このプロセスにより、古いデータがプルーニングされてもUTXOセットが正確に保たれます。</p>

  <h3 class="section-title">一次プルーニングでプルーニングされるもの</h3>
  <p><b>ブロックボディデータの削除</b> - 一次プルーニングは、トランザクションの入力、出力、署名、スクリプトを含む古いブロックからの実際のトランザクションデータを削除します。これには、UTXOマルチセット、UTXO差分、承認データ、および完全なブロックトランザクションストレージが含まれます。</p>
  <p><b>ヘッダーの保持</b> - トランザクションデータは削除されますが、ブロックチェーンの構造的整合性を維持するためにブロックヘッダーは保持されます。ブロックは「ヘッダーのみ」の状態に移行し、ヘッダーは存在するがボディはプルーニングされたことを意味します。</p>
  <p><b>必須データの保存</b> - システムは、プルーニングポイントのアンチコーン、DAAウィンドウブロック、GHOSTDAGブロックなど、コンセンサス検証に必要な重要なデータを保存します。これにより、プルーニング後もコンセンサス操作を継続できます。</p>

  <h3 class="section-title">UTXOセットが検証を可能にする方法</h3>
  <p><b>トランザクション検証プロセス</b> - 新しいトランザクションは、プルーニングポイントのUTXOセットと、それに続くすべてのUTXOの変更に対して検証できます。システムは、参照されたUTXOが存在し、二重支払いされていないことを検証します。これは、元のトランザクションデータがなくても可能です。</p>
  <p><b>状態の再構築</b> - プルーニングポイントのUTXOセットと、後続のブロックからのUTXO差分を組み合わせることで、現在の使用可能な状態を再構築できます。これにより、完全な履歴トランザクションデータがなくても、完全な検証機能が可能になります。</p>
  <p><b>コミットメントの検証</b> - システムは、ブロックヘッダーの暗号学的コミットメントを使用してUTXOセットの整合性を検証できます。これにより、プルーニングされたUTXOセットが、ブロックチェーンヘッダーが示すべきものと一致することが保証されます。</p>

  <h3 class="section-title">アーカイブノード対プルーニングノード</h3>
  <p><b>アーカイブノードの動作</b> - アーカイブとして設定されたノードは、一次プルーニングを完全に無視し、すべてのトランザクションデータを保持します。これらのノードはネットワークの完全な履歴台帳として機能しますが、はるかに多くのストレージを必要とします。</p>
  <p><b>プルーニングノードの効率</b> - 通常のプルーニングノードは、一次プルーニングを利用して、管理可能なストレージを維持しつつ、コンセンサス検証に完全に貢献します。UTXOセットは、完全な履歴データがなくても新しいトランザクションを検証するのに十分な情報を提供します。</p>

  <h4 class="subsection-title">プルーニングとジェネシス証明に関する懸念への対処</h4>
  <p>プルーニングによる台帳履歴のギャップが、チェーンの最初（ジェネシスブロック）からの検証可能性、特にプレマイニングがなかったことの証明を損なう可能性があるという懸念が繰り返し提起されています。</p>
  <p>この懸念は根拠がありません。理由は以下の通りです。</p>
  <ol>
      <li><strong>ジェネシスブロックはコードに組み込まれている：</strong> ジェネシスブロック自体はKaspaノードソフトウェアに「ハードコード」されています。このジェネシスブロックには空のUTXOセットが含まれており、プレマイニングがなかったことを証明しています。どのユーザーも公開されているソースコードでこれを確認できます。</li>
      <li><strong>ジェネシス証明：</strong> 各ノードは「ジェネシス証明」を保持しています。これは、台帳の現在の状態が実際に組み込まれたジェネシスブロックから進化したことを暗号学的に証明する短いデータチェーンです。そのような証明を偽造するには、台帳全体を作成するのに費やされたのと同等の作業が必要になります。言い換えれば、この証明は完全な履歴を所有するのと同じくらい強力です。</li>
      <li><strong>再構築された履歴の整合性：</strong> 完全な履歴を研究や利便性のために再構築する努力がなされていますが、そのプロセスは分散化されています。データは多くのユーザーから収集されます。残りの「ギャップ」を制御できる単一のアクターは存在せず、履歴の一部を選択的に「隠す」ことは不可能です。</li>
  </ol>
  <p>要するに、Kaspaのプルーニングメカニズムは、アーカイブノードがなくてもネットワークが安全、安心、透明性を保つように設計されています。チェーンがジェネシスから検証可能であることは、堅牢な暗号学的証明によって保証されており、完全かつますます重くなる履歴を保存する必要性によって保証されているわけではありません。</p>
  
  <div class="simplified-def">
    <h3 class="section-title">簡略化された定義</h3>
    <p><b>一次プルーニング</b> - 検証のためにUTXOセットを保持しつつ、古いブロックのトランザクションデータを削除すること。</p>
    <p><b>プルーニングポイントUTXOセット</b> - プルーニングポイントにおけるすべての使用可能な出力のスナップショットであり、検証の基盤として使用されます。</p>
    <p><b>「ヘッダーのみ」の状態</b> - トランザクションデータがプルーニングされたが、ヘッダーを保持しているブロック。</p>
    <p><b>UTXOの進行</b> - プルーニングポイントが進むにつれてプルーニングポイントUTXOセットを更新するプロセス。</p>
    <p>一次プルーニングは、UTXOセットを介して検証機能を維持しながら、ストレージ効率を可能にします。</p>
  </div>

  <h3 class="section-title">ビットコイン対Kaspa：フルノードのブートストラップ</h3>
  <p><b>ビットコイン</b> - フルノードは、ブートストラップのためにジェネシスからすべてのブロックデータをダウンロードして検証する必要があり、完全なトランザクション履歴データが必要です。ビットコインは初期同期後に簡単なプルーニングをサポートしていますが、新しいノードは初期状態を確立するために完全なブロックチェーン履歴を依然として必要とします。線形チェーン構造は、このプロセスを単純にしますが、ストレージを大量に消費します。</p>
  <p><b>Kaspa</b> - フルノードは、コンセンサスプロトコルへの一次プルーニングの統合により、完全な履歴データをダウンロードすることなく、プルーニング証明を使用してブートストラップできます。システムはプルーニング証明を検証し、暗号学的に検証可能なデータ（「信頼できるデータ」）を適用して初期状態を確立します。これらの「信頼できるデータ」は、いかなる当事者への信頼も必要としません。それらは、データがコンセンサスルールに準拠していることを保証する暗号学的証明によって数学的に検証されます。検証プロセスは、プルーニングポイント証明が有効なコンセンサス状態を表すことを暗号学的に証明し、信頼できるデータは、ブロックチェーンの期待される状態と一致することを確認するために厳密な精査を受けます。これにより、新しいノードは、外部の当事者を信頼することなく、完全な検証機能を維持しながら効率的に同期できます。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.juf0jn9hl1ev">第11章：アーカイブノード対フルノード</h2>
  <div class="img-container"><img alt="アーカイブノード対フルノード" src="images/image76.png"></div>
  <h3 class="section-title" id="h.knim47a94vo6">Kaspaアーカイブノード対プルーニングノード</h3>
  <p><b>プルーニングノードはフルノードです</b> - 一次および二次プルーニングを使用するプルーニングノードは、完全な検証機能を保持しているため、依然としてフルノードと見なされます。それらは、すべての新しいブロックを検証し、コンセンサスに参加し、外部の当事者を信頼することなくネットワークを提供できます。プルーニングポイント証明システムは、プルーニングされたデータであっても、これらのノードがブロックチェーンの完全な状態の暗号学的検証を維持することを保証します。</p>
  <p><b>アーカイブノードはオプションです</b> - すべての履歴データを保持するアーカイブノードは、Kaspaネットワークが無限に動作するために必要ではありません。プルーニングノードは、プルーニングポイント証明がプルーニングされた状態に関する数学的に検証可能な保証を提供するため、ネットワークは完全にプルーニングノードで動作できます。これはビットコインとは対照的です。ビットコインでは、新しいノードを起動するために、ネットワークはアーカイブノード（ジェネシスから完全なトランザクション履歴を保存するノード）を必要とします。</p>
  <p><b>追加の信頼要件なし</b> - プルーニングシステムは、信頼できる当事者ではなく暗号学的証明を使用することで、ビットコインのトラストレスモデルを維持します。新しいノードは、プルーニング証明から起動し、完全な履歴データをダウンロードすることなく、ブロックチェーンの完全な状態を検証できます。同時に、ジェネシスからすべてを保存するノードと同じセキュリティ保証を維持します。</p>
  <p><b>ネットワークの持続可能性</b> - この設計により、Kaspaネットワークは、参加者に常に増加するストレージ要件を課すことなく、持続的にスケーリングできることが保証されます。プルーニングノードは、アーカイブノードと同じコンセンサスセキュリティを提供しながら、ハードウェア要件を削減することで、より広範なネットワーク参加を可能にします。</p>
  <p><b>アーカイブノードの動作</b> - アーカイブとして設定されたノードは、一次および二次プルーニングを完全に無視し、すべてのコンセンサスデータ（および履歴アプリケーションデータ）を保持します。これらのノードはネットワークの完全なコンセンサス台帳として機能しますが、最大のストレージを必要とし、ネットワーク運用には純粋にオプションです。</p>
  <p><b>プルーニングノードの効率</b> - 通常のプルーニングノード（フルノード）は、プルーニングを利用して最大のストレージ効率を達成しつつ、多段階証明システムを通じて完全なコンセンサス検証能力を維持します。これらのノードは、セキュリティと検証能力の点でアーカイブノードと区別できません。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.xoj5wjv6tg4b">第12章：Kaspa：エネルギー効率の高い分散型アーキテクチャの進化</h2>
  <h3 class="section-title" id="h.pfav0qmvzt92">はじめに：お金と効率の物理学</h3>
  <p>分散型ネットワークの世界では、効率性は単なる贅沢品ではなく、生存のための特徴です。暗号通貨は、現実世界のエネルギーが安全で不変な価値記録に変換される、貨幣エネルギーシステムとして機能します。物理システムがエネルギーの無駄とエントロピーを最小限に抑えようと努力するように、適切に設計された暗号ネットワークも無駄と摩擦を最小限に抑えるべきです。ビットコインは、貨幣価値を作業量証明のエネルギー消費に結びつけることで、この概念の先駆けとなり、熱力学的コストによって保証された「デジタルゴールド」の形を作り出しました。しかし、ビットコインのアーキテクチャは、革命的であるにもかかわらず、そのスループットを制限し、マイナーが投入するエネルギーの一部を無駄にする構造的な非効率性を持っています。</p>
  <p>Kaspaの登場です。これは、分散型コンセンサスのアーキテクチャを再定義する次世代のプルーフ・オブ・ワークネットワークです。Kaspaは、単一のチェーンではなく、BlockDAG（有向非巡回グラフ）に基づいており、複数のブロックを並行して作成および処理できます。この設計は、システムのエントロピーと非効率性を最小限に抑えることを目的としており、Kaspaを経済的価値の保存と移動のための「効率的なエンジン」のようなものにしています。</p>
  
  <h3 class="section-title">エントロピー、エネルギー、そして貨幣システム</h3>
  <p>Kaspaの重要性を理解するためには、まずエネルギーとエントロピーが貨幣システムとどのように関連しているかを把握する必要があります。物理学では、ある場所で秩序（低エントロピー）を創造するには、エネルギーを消費し、別の場所でエントロピーを増加させる必要があります。この原理は貨幣にも当てはまります。金のような硬貨は、歴史的にその価値を採掘に必要とされる膨大なエネルギーと労働から引き出していました。ビットコインは、マイナーにブロックを追加するために高価な計算（ハッシュ化）を要求することで、同じ原理をデジタルに適用し、それによって各コインとブロックが費やされたエネルギーの証拠を保持することを保証しました。しかし、作業の大部分が無駄になったり、システム設計が不必要な摩擦を引き起こしたりすると、「貨幣エンジン」は熱の形でエネルギーを失います。</p>

  <h3 class="section-title">経済システムにおける摩擦</h3>
  <p>経済学において、摩擦とは価値の移動における損失や非効率性を引き起こすあらゆるものを指します。ビットコインは必要性からいくつかの摩擦を導入しました。その設計は速度とセキュリティをトレードオフします。トランザクションは新しいブロックを平均約10分間待ち、高いロールバック保証のためには6回の確認（約1時間）を待つのが慣例です。この遅延と低いスループットは経済的な摩擦を生み出します。さらに、ビットコインのマイニングプロセスは、孤立ブロックの形で無駄な作業を生み出すことがあります（2人のマイナーがほぼ同時に有効なブロックを見つけた場合、1つのブロックのみがメインチェーンの一部となり、もう1つは破棄されます）。これらの孤立ブロックは、マイナーが費やした実際のエネルギーを表しますが、台帳に持続的に貢献することはありません。</p>

  <h3 class="section-title">ビットコインの単一チェーンのボトルネック</h3>
  <p>ビットコインのブロックチェーンは、トランザクションのための単一車線道路と見なすことができます。一度に受け入れられるブロックは1つだけで、各ブロックは順番に並ぶ必要があります。もし2つのブロックが同時に到着した場合、一方は譲歩を強いられ、実質的に孤立ブロックとして破棄されます。この設計は、システムを秩序立てるために意図的に選択されましたが、その代償として深刻な性能制限を伴います。この単一チェーンアーキテクチャの限界はよく知られています。スケーラビリティの欠如、ブロック時間が短縮された場合の利己的なマイニング攻撃への脆弱性、そして無駄なブロックは固有の問題です。決定的なのは、ビットコインのコンセンサスが、決して台帳の一部にならないブロックに対して、マイニング作業のごく一部ではあるものの、無視できない部分を浪費していることです。これらの孤立ブロックはシステムのエントロピーです。つまり、無秩序を増大させ、有用な情報として保存されることなく熱として散逸したエネルギーです。その結果、ビットコインの膨大なマイニングエネルギーは、わずかなスループットしか生み出さないのです。</p>

  <h3 class="section-title" id="h.y2juit6511i3">KaspaのBlockDAG：無駄な作業のない並列性</h3>
  <p>Kaspaは、「ブロックが一直線に並ぶ必要がなければどうなるだろう？」と問いかけることで問題に取り組みました。単一車線の道路の代わりに、Kaspaはブロックのための複数車線の高速道路を使用し、多くのブロックを並行して作成し、それでも単一の台帳にマージすることができます。根本的な革新は、KaspaのBlockDAG（有向非巡回グラフ）アーキテクチャとGHOSTDAGコンセンサスプロトコルを組み合わせたものです。BlockDAGでは、ブロックはビットコインのように単一の前のブロック（「最長チェーン」の先端）を指すのではなく、グラフの異なる「先端」を含む複数の先行ブロックを参照できます。ビットコインでは競合または孤立と見なされるブロックは、Kaspaでは破棄されません。それらは台帳グラフに組み込まれます。DAG構造により、これらの同時ブロックが共存し、最終的にGhostDAGアルゴリズムによって一貫して順序付けられます。すべての有効なブロックは台帳履歴に貢献します。どのマイナーの作業量証明も無駄になりません。</p>
  <p>この設計が効率性に与える影響は目覚ましいものです。まず、孤立ブロックにマイニング能力が浪費されることはありません。次に、Kaspaの並列性によりスループットが大幅に向上します。Kaspaはメインネットで1秒あたり1ブロックの基本レートで動作し（最近は1秒あたり10ブロックにアップグレードされました）、ビットコインの1秒あたり0.1ブロックと比較して、設計上10倍のブロック頻度であり、さらなる増加も計画されています。さらに、各Kaspaブロックは小さく（ノード要件を低く保つため）、しかしはるかに頻繁に到着するため、トランザクションは多くのブロックに分散されます。最終的な結果は、1秒あたり数千トランザクションの潜在的なスループットです。実際、GhostDAGアルゴリズムは、一般的なハードウェアを使用してテストネットワークで10ブロック/秒で約3000トランザクション/秒をサポートできることを示しています。これは、控えめなハードウェア要件を維持しながら達成されました。言い換えれば、Kaspaのアーキテクチャは、スケーラビリティと分散化の間にトレードオフを強制しません。ノードの参入障壁を高めることなく、はるかに多くのトランザクションを処理します。各参加者は依然として通常のコンピューターでチェーンを検証できます。これは分散化にとって非常に重要です。強力なデータセンターノードに依存したり、コンセンサスを損なったりする多くの高スループットシステムとは異なり、Kaspaはマイニングノードとフルノードが広く分散した純粋なプルーフ・オブ・ワークシステムであり続けています。</p>
  <p>ブロックが並行して到着する場合、Kaspaはどのようにして一意で合意された履歴（単一の真実の源）を維持するのでしょうか？答えはGhostDAGです。これは、ビットコインのように「最長チェーン」だけでなく、ブロックの「最も重いサブグラフ」も考慮して、DAG内のブロックを順序付けるコンセンサスアルゴリズムです。GhostDAGは、各ブロックに、先行する検証済み履歴の量と、他のブロックを参照する方法に基づいて、一種のスコアまたは順序を割り当てます。これは、k-クラスターと呼ばれるパターン（本質的には相互に認識しているブロックのセット）を見つけ、それを使用して、どのブロックが主要な順序付けられた構造の一部であるか（「青」と色付けされる）を決定し、どのブロックが主要な構造の外にあるが、それでも含まれるか（「赤」）を決定します。このアルゴリズムは貪欲ですが、多くのブロックが処理中であっても、ナカモトコンセンサスと同様に、一意の履歴に収束することが証明されています。正式な保証は、ブロックが蓄積されるにつれて、特定のブロックの順序が変更される（つまり、フォークの巻き戻し）確率は指数関数的に減少することです。これはビットコインの確認と同様ですが、はるかに高いブロックレートでこのセキュリティが達成されます。実際には、Kaspaのトランザクションは、ビットコインよりもはるかに速く多くのブロックの下に深く埋められ、数秒で再編成に対して非常に安全になります。Kaspaチームは、GhostDAGの順序付けは、高いブロック生成レートであっても、「時間が経つにつれて逆転が指数関数的に難しくなる」と述べています。ファイナリティは高速です。ネットワークは、人間規模でのトランザクションの熱力学的不可逆性と呼ばれるものを達成します。</p>
  <p>すべてのブロックが保持されるため、Kaspaのマイナーは、他のブロックを保留したり、利己的にマイニングして孤立させたりするインセンティブがありません。これは、より高速なブロックチェーンの文脈では合理的な行動かもしれません。Kaspaの最大情報開示戦略（各ブロックは、それが知っているすべての先端を参照する）は、ネットワークがすべての並列ブロックについて迅速に通知されることを意味します。これにより、グラフは知識で溢れ、不確実性が減少します。情報理論の観点から見ると、Kaspaは、目に見えないフォークが長く存続しないようにすることで、ネットワーク状態のエントロピー（不確実性）を最小限に抑えます。すべてが統合されます。「最大開示の原則」は、本質的に、データを可能な限り効率的に共有することで、システムのエントロピー（不確実性）を削減することを目指しています。これは、物理的な原理と再び一致します。秩序を維持するためには、情報（またはエネルギー信号）をシステム全体に可能な限り効率的に伝播させたいのです。</p>
  <p>Kaspaがセキュリティや分散化を損なうことなくこれを達成していることに注目することが重要です。Kaspaは依然としてプルーフ・オブ・ワークを使用しており、これは各ブロックの有効性が実際に費やされたエネルギーによって保証されることを意味します。そして、ブロックが小さく、より頻繁に生成されるため、ノードの帯域幅とストレージは慎重に管理されています（プルーニングや効率的なUTXO管理などの技術を使用）。これにより、家庭用コンピューターでも対応できます。その結果、Kaspaは「主要なプルーフ・オブ・ステークネットワークに匹敵するパフォーマンスを備えた、プルーフ・オブ・ワークグレードのセキュリティと分散化」を提供します。強力なデータセンターノードに依存したり、コンセンサスを損なったりする多くの高スループットシステムとは異なり、Kaspaはマイニングノードとフルノードが広く分散した純粋なプルーフ・オブ・ワークシステムであり続けています。</p>
  <p>簡単に言えば、Kaspa の GhostDAG プロトコルは、ビットコインが避けられないと考えていた構造的なボトルネックを解消します。古い「セキュリティ対速度対分散化」のトリレンマは、Kaspa によれば、実際には完全に解決されています。線形チェーンモデルから脱却することで、Kaspa は中本聡のセキュリティを犠牲にすることなく、スループットの扉を開きます。これは、多くの研究者が何年もの間不可能だと考えていた偉業です。これらすべてが、ブロックが同期の取れた噴水から水滴のように継続的に到着するシステムにつながります。ビットコインの時計のように時間通りに断続的にブロックが到着するのとは異なります。Kaspa のトランザクションは数秒で確認され、通常は数十秒で確定します（再編成の可能性は無視できるほど小さい）。実際、Kaspa の設計目標は、確認時間がネットワーク遅延によってのみ制限されることでした。つまり、情報がインターネット上を物理的に移動できる限り速くということです。ネットワークはすでに平均約 10 秒で完全に確認されたトランザクションを配信しており、この数値はブロックレートの増加とともに減少します。ユーザーの視点から見ると、Kaspa を介して価値を送信することは、クレジットカード決済や現金送金とほとんど同じように感じられます。決済はほぼ瞬時に行われますが、不可逆的で信頼不要であるという追加の利点があります。</p>

  <h3 class="section-title" id="h.ttddfh4xlbpu">光速でのスループット達成</h3>
  <p>Kaspaが物理原理に合致していることを理解する1つの方法は、その遅延処理、つまり世界の片側からもう片側への遅延を調べることです。グローバルなインターネットのラウンドトリップタイム（RTT）は、本質的に信号が地球の反対側に到達して戻るのにかかる時間であり、最良の場合（光ファイバー内の光速とネットワークホップによって制限される）は200ミリ秒（0.2秒）程度です。ビットコインのような従来のブロックチェーンは、この制限よりも桁違いに遅く動作するため（ブロックあたり600秒）、ネットワーク遅延はその設計において重要な要素ではありません。それらは快適でゆっくりとした平衡状態にあります。しかし、Kaspaはブロック時間がネットワーク遅延と同程度の領域に大胆に踏み込みました。現在の新しいアップグレード（10 BPS）ではブロックあたり100ミリ秒であり、これは実際には地球の反対側への片道伝播よりも速いです。これは重要な閾値です。ブロック時間を1秒から0.1秒に短縮することは、単に10倍の量的改善ではなく、コンセンサスの再考を必要とする質的な飛躍です。</p>
  <p>なぜでしょうか？グローバルネットワークで100msブロックの単一チェーン（線形）コンセンサスを実行しようとすると、完全な混乱が生じます。ノードが1つのブロックについて聞いた途端に、さらに5つのブロックが見つかるでしょう。伝播遅延は、ネットワークが同期しないことを意味します。フォークが蔓延し、コンセンサスは崩壊するか、中央集権化するでしょう（常に最速の接続が勝つでしょう）。Kaspaは、このサブRTT領域でコンセンサスを実証した最初のProof-of-Workシステムであり、その多重リーダーGhostDAGが多くの同時ブロックをエレガントに処理できるからこそ、これを実行できます。主任開発者のマイケル・サットンがKaspaのCrescendoアップグレード（メインネットを1BPSから10BPSに移行させた）中に述べたように、「ブロックレートを10秒あたりに増加させることは、ブロック時間を100ms（<200ms ≈ グローバルRTT）に短縮することで達成されますが、これは本質的に並列性を許容するコンセンサスプロトコルによってのみ保証できます…したがって、RTT閾値を超えることは、量的な飛躍だけでなく、質的な飛躍です。」言い換えれば、Kaspaの設計は、情報伝達の物理的限界に根本的に沿っています。物理法則（光速、ネットワーク帯域幅）が許容する最大速度で動作するように構造化されていますが、線形チェーンは、セキュリティを犠牲にしたり、より小さなネットワーク半径を前提としたりすることなく、この限界を安全に超えることはできません。</p>
  <p>分散システムという文脈で、これがどれほど注目に値するかを強調する価値があります。Kaspaは、グローバルな非同期コンセンサスを、グローバルな通信遅延よりも短いブロック時間で達成します。そして、ネットワークを縮小したり、特別な信頼設定を必要としたりすることなく、これを実現しています。ネットワークは広大で許可不要のままであり、ノードは世界中のどこにでも配置でき、標準的なインターネット接続で接続されています。それでも、Kaspaはこれらの条件下で、どの単一チェーンよりも速くブロックを生成し、確認します。GhostDAGプロトコルは、本質的に、厳格な最長チェーンルールのもとでは古典的なコンセンサス理論では不可能だと考えられていたことを可能にします。つまり、絶え間ないミニフォーク（並列ブロック）にもかかわらず、すべてを一致させることです。その考え方は、これらのフォークの存在を許容し、その後確率的に順序付けることで、混乱を受け入れ、それを組織化することです。完全に防ごうとするのではなく。その結果、最大限のスループットが得られます。</p>
  <p>Crescendo ハードフォークの有効化後、Kaspa 開発者は、システムが 10 BPS であってもノードを実行するのにスーパーコンピューターは必要ないように設計されていると述べました。Rust 実装とプロトコル最適化により、平均的な PC と家庭用インターネット接続でも、毎秒 10 ブロックと毎秒数千トランザクションに対応できることが保証されています。これは、あらゆるレベルでの効率性を目指す設計思想を示しています。それは、純粋なスループットだけでなく、計算リソースと帯域幅の効率的な使用も含まれます。たとえば、ブロックはコンパクトに保たれ、DAG 構造は肥大化しないように剪定および管理されます。Kaspa には、ネットワーク条件に適応し、状態サイズを制限するための新しい技術（今後の DAGKnight や剪定戦略など）も含まれています。これらの選択はすべて、ほとんど物理学的なミニマリズムを反映しています。つまり、無駄の排除です。それは、ハッシュパワーの無駄、時間の無駄、ストレージの無駄のいずれであってもです。ビットコインのマイニングが、多くの熱（トランザクションあたりのエネルギー無駄）を生成すると批判されることがあるとすれば、Kaspa はスループットを向上させ、よりエネルギー効率の高いハッシュアルゴリズム（kHeavyHash）を使用することで、トランザクションあたりのエネルギーを大幅に削減します。Kaspa チームは、kHeavyHash が光学マイニングやリソースの少ないマイニングと互換性があるように明示的に設計しました。これは、はるかに少ない電力で動作する特殊なハードウェアで実行できる可能性があることを意味します。DAG の「無駄なブロックなし」ポリシーと組み合わせることで、Kaspa は他の PoW ネットワークよりもトランザクションあたりまたは転送された価値あたりでエネルギー消費が少なくなります。簡単に言えば、Kaspa はマイナーが投入するすべてのジュールでより多くのことを達成できます。これは、その優れたエンジニアリングの証です。独立したオブザーバーもこの効率性を指摘しています。「kHeavyHash アルゴリズムは、エネルギー消費を最適化するように設計されており、[Kaspa] は…ビットコインよりもリソース集約的ではありません。」私たちはこれをシステムの熱力学的効率の向上と見なすことができます。入力エネルギーのより大きな部分が、無駄なハッシュや待機時間ではなく、安全で最終的なトランザクション（有用な仕事）に変換されます。</p>
  <p>物理的限界を責任を持って押し広げることで、Kaspaは熱力学的に非常に効率的な貨幣ネットワークとしての地位を確立しています。ブロック生成のペースを可能な限り高速な通信に合わせ、冗長な作業を排除し、すべての作業がトランザクションの順序付けに貢献することを保証します。例えるなら、ビットコインが多くの廃熱を発生させ、低速で動作する古い熱機関だとすれば、Kaspaは理論上の効率限界に近いところで動作する現代のタービンのようなものです。つまり、燃料（ハッシュエネルギー）の各単位から最大限の有用な動き（トランザクションスループット）を引き出します。物理法則は厳格な上限を定めており、Kaspaはその上限に到達することを決意しています。この技術進化の「方向性のある流れ」（少ない入力でより多くの出力）との整合性は、Kaspaが他の多くのシステムで観察されてきた進化の軌跡をたどっていることを示唆しています。単一コアからマルチコアプロセッサ、並列処理へ。ダイヤルアップからブロードバンドインターネットへ。馬車から多車線高速道路へ。並列性を活用し、内部抵抗を減らすシステムは、単一の逐次プロセスに固執するシステムを必然的に凌駕します。</p>

  <h3 class="section-title" id="h.uttpgy92hgk">摩擦を減らし、価値をより良く保持する</h3>
  <p>Kaspa の設計が持つ技術的な利点は、経済的に深い意味合いを持ちます。貨幣システムにおけるエントロピーと摩擦を減らすとき、私たちは価値が留まり、流通するためのより好ましい環境を作り出します。経済を生きている生態系、あるいは電力網のように考えてみましょう。エネルギー（またはお金）が必要な場所に最小限の損失で自由に流れることができれば、システムは繁栄し、成長します。Kaspa の低遅延で高スループットなネットワークは、誰もがどこでも、仲介者や高い待機コストに吸い取られることなく、迅速かつ安価に価値を交換できることを意味します。この特性は自然に利用を引きつけます。ユーザーは、セキュリティが同等であれば、1 時間待つシステムよりも、支払いが 1 秒で確認されるシステムを好むでしょう。利用が増えるにつれて、流動性と資本がネットワークに引き寄せられ、フィードバックループでその有用性が高まります。経済学の基本は、2 つの選択肢がある場合、人々は取引コストが最も低い方を選ぶ（他の条件が同じであれば）ことを教えてくれます。そして、お金は取引に対する抵抗が最も少ないチャネルを通って流れるでしょう。Kaspa は、この低インピーダンスチャネルとして自らを提示しています。「最小の散逸仕事、最小の取引インピーダンス、最大の貨幣の明確さ」と、ある観察者は資本が流れ込む収束点を表現しました。Kaspa を使用することで、従来の障壁（確認の遅延、スループットの制限、混雑時の高額な手数料）が大幅に最小化され、貨幣エネルギーの「パイプ」が広くて滑らかになります。</p>
  <p>プランKは、Kaspaの経済性についてのインタビューで、効率的な貨幣がどのようにエネルギーを導くかを説明するために生物学的な類推を用いました。良い貨幣は植物の血管系のようなもので、栄養（エネルギー）を光合成する葉（生産的な仕事）に運び、資源が寄生虫や不活性な部分に吸い取られるのを防ぎます。この類推において、Kaspaは効率的なエネルギーの流れを促進する低エントロピーの貨幣形態と見なすことができます。その速度と容量は、経済的エネルギー（価値）が生産的な用途（商品やサービスの実際の移転）に流れることを保証し、バックログやレイヤー間の裁定取引で浪費されることを防ぎます。一方、そのプルーフ・オブ・ワーク基盤は、「安易な貨幣」で発生するエネルギーの逸脱を防ぎます。例えば、法定通貨はプランKの類推では寄生植物に例えられました。中央当局によってインフレさせられたり、複製されたりする可能性があり、価値を希薄化することで生産的な経済からエネルギーを効果的に吸い取ります。Kaspaは、ビットコインと同様に、新しいコインの作成に実際の作業を要求し、供給量の増加を厳しく制限することで、そのような希薄化から自らを免疫化します。プランKが述べたように、「金、ビットコイン、Kaspaは、コピーできない[ホルモン]のようなものであり、エネルギーの逸脱を防ぎます」。簡単に言えば、これらの硬貨は、それらを作成するために費やされたエネルギーをロックします。それらは、価値の希薄化による漏洩なしに、経済的価値の安全な貯蔵庫を提供します。</p>
  <p>Kaspa は、この硬貨の原則を日常生活の使いやすさの領域にまで広げています。ビットコインは、分散型ネットワークが価値を安全に保存できることを証明しました（時間の経過とともにエントロピーが低い）。しかし、Kaspa は効率的に価値を移動させること（トランザクションにおけるエントロピーが低い）も目指しています。ビットコインの偽造不可能なコストと摩擦のないトランザクション層を組み合わせることで、Kaspa は貨幣の完全なソリューションとして位置づけられています。つまり、価値の保存手段、交換手段、および会計単位のすべてを、通常の妥協なしに提供します。歴史的に金が日常の取引に代替品（紙幣や法定通貨など）を必要とした理由を思い出すのは有益です。それは、金が重く、移動が遅く、摩擦を生み出したからです。ビットコインも、遅く、スループットが限られているため、迅速な支払いのギャップを埋めるためにレイヤー2ネットワークや競合するコインを招き入れ、本質的に交換手段の役割を「よりソフトな」通貨に譲りました。一方、Kaspa は十分高速でスケーラブルであるため、ボリュームを処理するための二次的な貨幣ネットワークを必要としません。Kaspa は、高整合性の決済層と高速トランザクション層の両方になることができます。これは、経済活動が「価値保存ネットワーク」と「支払いネットワーク」の間を常に切り替える必要がない（そして、それに伴うすべての交換摩擦とセキュリティの妥協がない）未来を示唆しています。代わりに、単一のネットワークがすべてを効率的に行うことができます。実際、支持者は、Kaspa がトリレンマを解決したため、「Kaspa が埋められない貨幣市場のギャップはもはや存在しない」と主張しており、ビットコインのような遅い基本保存手段や、より高速だが弱い代替手段の必要性を排除しています。ビットコインが高価な決済層として残り、Kaspa がより交換用になるのか、それとも Kaspa が最終的に両方の役割を吸収するのかは、市場が決定するでしょう。しかし、1 つだけ明らかなことがあります。それは、無駄を減らし、より多くのものを提供するシステムは、そうでないシステムに長期的には勝るということです。これは、貨幣システムに適用される自然淘汰です。</p>
  <p>摩擦が少ないということは、Kaspaエコシステムにおいてマイナーとユーザーがより良く連携していることも意味します。ビットコインでは、ユーザーは混雑時に高額な手数料を支払うことについて不満を言うことがあり（最終的にはマイナーに支払われる）、マイナーは孤立ブロックによる変動と損失に直面します。Kaspaでは、高スループットにより手数料が低く抑えられ（容量が豊富であるため）、孤立ブロックのない設計により、マイナーはネットワーク遅延による報酬の損失がありません。マイナーは依然として正当な報酬を得ます。実際、Kaspaのブロック報酬は単位時間あたりより多くのブロックに分散されるため、逆説的にマイニングプロセスはより細かく、より公平になります（10分ごとに1人の勝者がいるのではなく、1秒あたり複数のマイナーが報酬を得ることができます。これは「マルチリーダー」システムであり、利点が平均化されます）。より多くのマイナーがほぼ同時にブロックを含めることができるため、特定の時間帯を独占するマイナーの独占的傾向を減らすことができます。「各遅延ラウンド内での競争の増加」は、MEV（マイナー抽出可能価値）や操作の削減にも影響を与えます。なぜなら、ブロックが並列である場合、単一のアクターがトランザクションの順序を制御することははるかに困難になるからです。実際、Kaspaの並列性は、公平性を促進するわずかな混乱をもたらします。つまり、厳密な順序制御を必要とする特定の悪用を適用することが不可能になり、それによって市場結果のエントロピー（市場価格とトランザクションがマイナーの干渉ではなく真の需要と供給を反映する）が減少します。これは、Kaspaのアプローチがシステム内の価値を保持する傾向がある別の例です。システム動作を熱力学的に不可逆的にすることで、つまり、どのアクターも自分の利益のためにトランザクションを簡単に巻き戻したり再編成したりできないようにすることで、ネットワーク状態の変更（実行されたトランザクション）は真正で永続的になります。これは、経済の流れをほぼ物理的な必然性に合わせるものです。Kaspaで何かが起こると、それは本質的に完了しており、簡単に元に戻したり不正行為をしたりすることはできません。</p>
  <p>マクロ経済的な観点から、通貨とネットワークのグローバルな競争を進化の風景と見なすと、低抵抗と高整合性を提供するKaspaのようなシステムは、「貨幣質量」を蓄積する傾向があります。時間が経つにつれて、流動性は流動性を生み出します。ユーザーは他のユーザーや商人がいる場所に行きます。Kaspaがビットコインのようなセキュリティを維持しながら、大幅に優れたパフォーマンスを提供し続けるならば、より多くの経済活動がKaspaに移行すると考えるのは合理的です。私たちは歴史的に、法定通貨が摩擦が少ないために取引で金を置き換えたことをすでに見てきました。金は優れた価値貯蔵手段ですが、今や暗号通貨は、硬さとデジタル速度を組み合わせることで法定通貨に挑戦しています。Kaspaは次のステップと見なすことができます。つまり、PoWマネーの究極の硬さと現代ネットワークの究極の速度を組み合わせたものです。物理学の言葉で言えば、Kaspaは貨幣エネルギーの「重力終点」となる可能性があります。それは、最小のポテンシャルエネルギー状態を表すため（つまり、あなたの資金が同時に安全で使いやすいシステムを簡単に見つけることはできません）、資本を引き付ける巨大なアトラクターです。価値が流れるためのより簡単な経路（より低いエネルギー状態）がない場合、あなたは平衡に達しており、Kaspaはその分散型マネーの平衡点となることを目指しています。</p>

  <h3 class="section-title">不可逆性およびKaspaとビットコインにおける時間の矢</h3>
  <p>プルーフ・オブ・ワーク・システムの特徴的な側面は、時間の矢をどのように確立するかです。各ブロックは不可逆的なイベントです。作業が完了しブロックが承認されると、それを元に戻すには同等（またはそれ以上）のエネルギー消費が必要になります。この単方向の作業機能は、ブロックチェーンに時間的な方向性を与えます。物理学のエントロピーと同様に、前進する（新しいブロックをマイニングし、エントロピーを増加させる）のは簡単ですが、外部からの介入なしに後退する（ブロックを元に戻し、エントロピーを減少させる）のは非常に困難です。ビットコインのブロックチェーンは、エネルギーによって保護されており、しばしば時間の矢に例えられます。つまり、ますます「確立された」履歴のシーケンスです。Kaspaはこの特性を継承していますが、それを加速させます。ブロックが非常に速く到着し、GhostDAGが台帳履歴を迅速に深めるため、Kaspaのトランザクションの不可逆性はビットコインよりも速く進行します。Kaspaのトランザクションが元に戻される可能性は、新しいブロックが順序を固めるにつれて、毎秒指数関数的に減少します。ビットコインでは、高い信頼を得るために通常6ブロック（約1時間）が参照されます。Kaspaでは、同様のセキュリティレベルは、おそらく12ブロック程度で達成できる可能性があります。これは、1ブロック/秒の場合で約12秒（10ブロック/秒の場合で1秒強）ですが、他の遅延要因も関係します。</p>
  <p>これは、Kaspa の台帳の最終性が、リアルタイムの不可逆性に非常に近いものを達成していることを意味します。システム動作は、非常に迅速に後戻りできない点に達する不可逆的な熱力学プロセスを反映しています。たとえば、2 つの競合するトランザクション（二重支払い試行）が発行された場合、Kaspa の高速なブロック包含と順序付けにより、勝者が決定され、数秒以内にその上に確認が積み重ねられ、敗者の元に戻す試みはますます無意味になります。ビットコインでは、この不確実性（エントロピー）の期間は数分続く可能性があり、それでも、十分なハッシュパワーを持つ攻撃者によって低エントロピー状態（多くの確認が蓄積される前）で悪用される可能性があります。Kaspa はこの期間を短縮し、履歴を元に戻すコストをほぼ即座に非常に高くします。これは、Kaspa が攻撃者が登らなければならない熱力学的勾配を増加させていると見なすことができます。つまり、より急な丘がより速く急になるということです。これは再び効率性に関連しています。ネットワークはハッシュパワーをセキュリティ（秩序）に変換するのに時間を浪費しないため、攻撃者は悪用できる長い脆弱性の「贅沢」を持っていません。不確実性のエントロピーはシステムから迅速に排出され、安定した非常に秩序だった状態（確認されたトランザクション）が残ります。</p>
  <p>もう一つの視点は、ランダウアーの原理です。これは、情報の1ビットを消去するには、不可逆的なエネルギーコスト（熱散逸）がかかるという物理学の概念です。ブロックチェーンでは、トランザクションを「消去する」（確認されたトランザクションを履歴から削除する再編成によって）ことは、エネルギー的に非常にコストがかかります。これが、正直なマイナーがハッシュパワーの大部分を制御している場合、大規模な再編成が不可能である理由です。Kaspaは、トランザクションデータビットがほぼ瞬時に多くのブロック（情報ビット）に組み込まれることを保証し、情報が根付き、熱力学的に消去するのが高価になるようにします。本質的に、Kaspaは情報理論と熱力学を整合させています。つまり、情報（台帳の状態）は、作業量証明によって固定されたエントロピー耐性のある永続性を迅速に獲得します。そして、Kaspaは入力エネルギーをより効率的に使用するため（無駄なブロックがなく、単位時間あたりの確認数が多い）、ビットコインよりも高い「エネルギー単位あたりの不可逆性」を達成していると言えるでしょう。Kaspaでの各マイニングジュールは、多くのトランザクションの最終性に貢献しますが、ビットコインでは、各ジュールはより少ないトランザクションを保護します（そして、一部のジュールはカウントされない可能性のあるブロックに費やされます）。</p>
  <p>時間の矢の比喩は適切です。ビットコインの矢はゆっくりと、しかし確実に前進し、歴史をしっかりと確立するのに時間がかかりますが、Kaspaの矢は高速で飛び、イベントを時間内に迅速に固定します。両方の矢は同じ方向を指しています。これは熱力学の第二法則（エネルギー消費）によって課せられたものですが、Kaspaの矢は単位時間あたりより多くの距離（台帳の深さ）をカバーします。これは実用的な利点（ユーザーエクスペリエンス、スループット）だけでなく、哲学的にも、Kaspaの設計が複雑なシステムの「自然な」方向性、つまりエネルギー消費によってより短い時間でより大きな秩序を達成するという方向性と調和していることを示唆しています。ビットコインがエネルギー＋時間＝セキュリティであることを示したとすれば、Kaspaは、より良い設計によって、内部の非効率性を排除するだけで、同じエネルギーで同等のセキュリティをはるかに短い時間で達成できることを示しています。それは基本的な法則に違反するものではありません。単にビットコインが見過ごしている機会を無駄にしないだけです。</p>

  <h3 class="section-title">結論：Kaspaは貨幣ネットワークの効率性フロンティア</h3>
  <p>物理学と経済学という二重のレンズを通してKaspaを考察すると、あるテーマが浮かび上がってきます。それは、システムがエネルギーと情報の処理において最適な効率へと進化するということです。経済学では、貨幣は扱いにくい商品から金へ、金に裏付けられた紙幣へ、そしてデジタルネットワークへと進化してきました。各段階は、信頼と価値を維持しながら摩擦を減らすことを目的としていました。コンピューティングとネットワークでは、私たちは直列処理から並列処理へ、アナログ遅延から光速に近い信号へと移行してきました。Kaspaは、分散型貨幣の分野におけるこれらの進化の道のりの収束を表しています。それは、エネルギーに裏付けられたプルーフ・オブ・ワークの堅牢性と最終性、つまりビットコインを「デジタルゴールド」の一種にする側面を取り入れ、そのエネルギーを利用するシステムの効率性を大幅に高めています。その結果、価値のエンジンと表現できるネットワークが誕生しました。電気エネルギー（ハッシュ作業）をデジタル経済的価値（安全なトランザクションとコインの発行）に最小限の無駄で変換し、その価値を必要な場所に迅速に送ります。</p>
  <p>Kaspaをビットコインと比較する際、それは競争ではなく、分散型アーキテクチャの進歩についてです。ビットコインは、貨幣に対する熱力学的なアプローチが機能することを示したプロトタイプでした。Kaspaは、無駄（エントロピー）を最小限に抑え、スループット（有用な仕事）を最大化するためにアーキテクチャを洗練させた進化形であり、ビットコインを偉大にした本質（プルーフ・オブ・ワークによる分散化とセキュリティ）を失っていません。私たちがKaspaをビットコインと比較したのは、両者がPoWの基本的な基盤と健全な金融政策を共有しており、主に構造設計が異なるためです。そして、その違い、つまりBlockDAGとブロックチェーンの違いが、大きな違いを生み出しました。KaspaのBlockDAGは、ビットコインのボトルネックに対する自然な解決策であり、後から考えるとほとんど明白です。1つのレーンが遅すぎるなら、レーンを追加する。ブロックを破棄するのがエネルギーの無駄なら、すべてを保持する方法を見つける。グローバル同期を待つのが遅延を引き起こすなら、ある程度の非同期性を許容し、それをアルゴリズムで解決する。これらは、ある意味で、技術が実装を可能にした後には常識的な最適化です。GhostDAGの素晴らしい洞察は、多くのリーダー（マイナー）が混乱なく同時に協力する方法を見つけることでした。それは、ソロ演奏ではなく、よくオーケストレーションされた交響曲のようなものです。これは、適切なルールがあれば、見かけ上の混乱から秩序が生まれることを示しており、物理システムが制約を賢く適用されたときにどのように自己組織化するかを反映しています。</p>
  <p>Kaspaの設計選択の最終結果は、一部の人々によると、効率的な価値計算における自然な集大成を構成するシステムです。それは物理が許す限り高速であり、プルーフ・オブ・ワークが可能な限り安全であり、グローバルに包括的なネットワークがそうあるべきであるほど分散化されています。貨幣と熱力学の間の根本的なつながりを断ち切ることなく、より速く、より効率的になることができるでしょうか？おそらくそれほどではありません。新しい物理学や信頼の妥協なしには。Kaspaはすでに将来的に毎秒100ブロックを目指しており、ほぼ連続的なブロックストリームに近づいています。そして、その開発者は、条件に応じて確認速度を調整する適応機能（DAGKnightなど）を統合しています。私たちは、分散型コンテキストにおけるオンチェーンスケーリングの実用的な限界に近づいています。これ以上の大きな進歩は、おそらく根本的に異なるアプローチ（または中央集権化の受け入れ）を必要とするでしょう。この意味で、Kaspaは効率性のフロンティアです。Kaspaよりも多くの無駄やリスクを伴わずに、大規模に大幅に高いスループットや低いレイテンシを実現することはできません。Kaspaは、リソースを最適に利用するバランスを見つけました。</p>
  <p>熟練した暗号専門家や研究者にとって、Kaspaは熱力学、情報理論、経済学の原理が収束する魅力的なケーススタディを提供します。それは、分散型金融ネットワークが物理システムと同じ方法で分析できるという考えを検証します。つまり、エネルギー入力、作業出力、およびエントロピーとしての非効率性です。これらの非効率性を削減することで、Kaspaは単に性能が向上するだけでなく、根本的により持続可能で魅力的な経済システムを創造します。無駄の少ないシステムは、マイナーの作業がより有効に活用され、ユーザーの手数料が低く抑えられ、より多くの価値がオーバーヘッドで燃焼されることなく流通することを意味します。時間が経つにつれて、これはより多くの参加、より多くの投資を引き付け、ネットワーク効果を強化します。これは、効率的なエンジンが燃料を節約するだけでなく、新しい機能（より長い走行距離、より重い荷物）を可能にするのと同様に、効率的なブロックチェーンは、より遅いチェーンでは窒息するような経済活動やユースケースを可能にします。</p>
  <p>結論として、Kaspaは、中本聡の発明をその魂を失うことなく拡張するという10年以上の研究の集大成と見なすことができます。それは、物理法則と健全な経済学が分散化の敵ではなく、それを改善するための指針であることを示しています。Kaspaの成功は、最も忠実に最小抵抗の経路と最小エントロピー生成の経路をたどる貨幣システムが勝利することを意味します。これは物理学と高度に一致する結果です。実際には、Kaspaは高スループット、低摩擦、安全なネットワークを表しており、光速と大多数の誠実さによってのみ制限される、単一のプロトコル内で国家の価値を運ぶことができます。ビットコインが熱力学的金融時代への扉を開いたとすれば、Kaspaは経済エネルギーの流れを電子の流れと同じくらい効率的にすることで、その時代を加速させます。技術と貨幣の壮大な物語において、Kaspaは効率が運命であるという説得力のある証拠として際立っています。つまり、2つのシステムが与えられた場合、無駄を最もよく最小化し、有用な仕事を最大化するシステムが未来を引き寄せるでしょう。そしてKaspaは、それがまさにそのシステムであるという説得力のある、技術的に健全な議論を提示しています。それは、摩擦のない、価値を保持する、そして最終的にはより人間中心の貨幣ネットワークへの進化的な飛躍です。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="h.e01avawvoirc">第13章：Kaspaとビットコインの順序付け</h2>
  <div class="img-container"><img alt="Kaspaとビットコインの順序付け" src="images/image33.png"></div>
  <h3 class="section-title">ブロックの選択と順序付け：最重量チェーン対青い作業量</h3>
  <h4 class="subsection-title">ビットコインの最重量チェーンルール - 逐次選択</h4>
  <p>ビットコインのコンセンサスメカニズムは、ネットワークが単一のブロックチェーンを維持するという線形原理で動作します。マイナーが同時に新しいブロックを作成すると、ネットワークは競合するチェーン間で選択を迫られます。最重量チェーンルールは、最も多くの累積プルーフ・オブ・ワークを持つチェーンを選択することでこれを解決し、したがって最大の計算投資を表すパスを選択します。このアプローチは、勝者総取りのシナリオを生み出し、1つのチェーンのみが生き残り、競合するすべてのブロックは孤立します。孤立したブロックは、有効なトランザクションを含み、実際の計算作業を表していますが、ネットワークのセキュリティやトランザクション処理能力には何も貢献しません。この設計は明確な順序付けを保証しますが、各高さレベルで1つのブロックしか受け入れられないため、本質的にスループットを制限します。この例では、ビットコインによってブロックがどのように破棄されるかを見ることができます。</p>
  <div class="img-container"><img alt="ビットコインの孤立ブロック" src="images/image38.png"></div>
  
  <h4 class="subsection-title">Kaspaの青い作業量選択 - 並列統合</h4>
  <p>KaspaのGHOSTDAGプロトコルは、このアプローチを有向非巡回グラフ（DAG）構造内で動作するように拡張し、複数のブロックが共存してネットワークセキュリティに貢献できるようにします。競合するブロックを破棄する代わりに、GHOSTDAGはそれらを「青」（正直で、コンセンサスに貢献する）または「赤」（潜在的に競合するが、それでも保持される）に分類します。「青い作業量」メトリックは、DAG内の青いブロックからのみ累積されたプルーフ・オブ・ワークを表します。この選択的な蓄積により、コンセンサスが有効なブロックのみがセキュリティ計算に貢献し、同時に赤ブロックの作業とトランザクションを全体的な構造内に保持することが保証されます。この例では、ビットコインによって破棄されたブロックが、k=0の場合でもKaspaのDAGに含まれていることがわかります。</p>
  <div class="img-container"><img alt="Kaspaにおける並列統合（青と赤のブロック）" src="images/image20.png"></div>
  
  <h4 class="subsection-title">親ブロックの選択とメインチェーンの形成</h4>
  <p>新しいブロックがDAGに入ると、GHOSTDAGはいくつかの可能な親候補の中から「選択された親」を選択する必要があります。この選択プロセスは、各潜在的な親の「青い作業量」値を調べ、正直なブロックから最も高い累積「青い作業量」値を持つものを選択します。これはブロックBであり、その親の中から最良の親（最も多くの作業量を持つ親）を選択しています。</p>
  <div class="img-container"><img alt="親ブロックの選択とメインチェーンの形成" src="images/image39.png"></div>
  <p>この選択された親は、DAG内にメインチェーンを確立するための基礎となります。メインチェーンは、ビットコインの線形チェーンと同様の決定論的な順序付けメカニズムを提供しますが、より複雑なDAG環境で動作します。メインの親を選択した後、プロトコルは「マージセット」と呼ばれる残りのすべてのブロックを処理します。これは、DAGに含まれているが、選択された親として選択されなかったブロックです。親を選択した後、DAGを通じて選択された親をたどることができます。これにより、この画像でわかるチェーンが作成されます。</p>
  <div class="img-container"><img alt="DAGを通じて選択された親をたどる" src="images/image10.png"></div>
  
  <h4 class="subsection-title">順序付けとトランザクション処理</h4>
  <p>「青い作業量」選択によって作成されたメインチェーンは、トランザクション処理の主要な順序付けメカニズムとして機能します。トランザクションは、まず選択された親から処理され、次にコンセンサスで合意された順序でマージセットブロックから処理されます。これにより、すべてのノードが再現できる決定論的なシーケンスが作成され、ネットワーク全体で一貫したトランザクションの順序付けが保証されます。</p>

  <h3 class="section-title">基本的なアーキテクチャの違い</h3>
  <p><b>ビットコインのアプローチ：</b> 各ブロックが正確に1つの親を持つ単一の線形シーケンスを作成します。競合は、競合するブロックの永久的な除外をもたらし、勝利したチェーンのみがネットワークセキュリティに貢献します。</p>
  <p><b>Kaspaのアプローチ：</b> ブロックが複数の親と子を持つことができるDAG構造を維持します。競合は、除外ではなく分類によって解決され、複数のブロックがネットワークセキュリティに貢献しつつ、メインチェーンを介してコンセンサスを維持できます。</p>

  <h3 class="section-title">スループットとセキュリティへの影響</h3>
  <p>ビットコインの線形アプローチは強力なセキュリティ保証を提供しますが、スループットを約10分に1ブロックに制限します。競合するブロックの孤立は、計算リソースの無駄とトランザクション容量の損失を表します。</p>
  <p>Kaspaの「青い作業量」システムは、セキュリティ特性を維持しながら、はるかに高いスループットを可能にします。DAG内で青と赤の両方のブロックを保持することで、システムはネットワークの計算作業とトランザクション処理能力のより大きな部分をキャプチャします。メインチェーンは、複雑さが増しても決定論的な順序付けを保証し、コンセンサスの信頼性を犠牲にすることなく並列ブロック作成を可能にします。</p>

  <h3 class="section-title">2013年のビットコインのロールバック：ファイナリティの教訓</h3>
  <p>2013年3月、ビットコインネットワークは、「最長チェーンが有効なチェーンである」という基本原則に矛盾する重大なイベントを経験しました。</p>
  <ol>
      <li><strong>チェーンの分岐：</strong> Bitcoin Coreバージョン0.8を使用するマイナーが、古いバージョン（0.7）と互換性のないブロックを生成しました。これにより、チェーンの分岐（フォーク）が発生しました。</li>
      <li><strong>プロトコルよりも社会的調整が優先された：</strong> 0.8チェーンが長くなりましたが、コア開発者と大規模なマイニングプールは、このチェーンを放棄し、より短いが互換性のある0.7チェーンに戻るために社会的に調整しました。</li>
      <li><strong>ファイナリティが破られた：</strong> 0.8チェーンから24ブロックが孤立しました。それらに含まれていたトランザクションは、かつては有効と見なされていましたが、ビットコインの正規の履歴から消去されました。</li>
  </ol>
  <p>このイベントは、ビットコインのコンセンサスが純粋に決定論的ではなく、人間の介入を必要とする場合があることを証明しました。Kaspaでは、そのような分岐は不可能です。すべてのブロックは、同時にマイニングされたとしても、DAGに含まれ、GHOSTDAGは一貫してアルゴリズム的に順序付けられた履歴を選択します。ロールバックや社会的調整の必要はありません。ファイナリティは決定論的です。</p>

  <hr class="chapter-break">
  
  <h2 class="chapter-title" id="chapter14">第14章：Kaspaのレイヤー2ビジョン：ZKロールアップとブリッジング</h2>
  <h3 class="section-title">レイヤー2ソリューションの必要性</h3>
  <p>Kaspaはそのベースレイヤー（レイヤー1）で印象的なスケーラビリティを提供しますが、複雑な分散型アプリケーション（DeFi、ゲーミングなど）の未来はレイヤー2ソリューションにかかっています。これらは、メインチェーンのセキュリティの恩恵を受けながら、複雑な計算をオフチェーンで実行することを可能にします。Kaspaは「Based ZK-Rollups」に焦点を当てており、そこではレイヤー1（Kaspa）がシーケンシング、データ可用性、および決済レイヤーとして機能します。</p>
  
  <h3 class="section-title">課題：包含時の証明 vs. 実行の不確実性</h3>
  <p>Kaspaのような並列化されたL1は「実行の不確実性」を導入します。トランザクションは、最終的なグローバルな順序が決定される前にDAGに包含されます。これは、マイナーが正確なシーケンスを予測するのを防ぐため、MEV耐性にとって利点となります。</p>
  <p>しかし、これはZK-Rollupsと矛盾を生じさせます。ZK-Rollupsは、理想的には「包含時の証明」を必要とします。ZK証明を生成するためには、事前状態が既知で曖昧さがない必要があります。しかし、Kaspaでは、並列処理のためにこの状態が包含時に定義されていません。</p>
  <p>Kaspaの解決策は、マルチリーダーコンセンサスとその実行の不確実性を選択することです。したがって、ZK証明は延期され、トランザクションの順序が収束し、明確な状態が確立された後にのみL1に提出されなければなりません。これは新たな課題を生み出します。必要な証明が決して届かなかった場合はどうなるのでしょうか？</p>
  
  <h3 class="section-title">時間制限付き証明決済</h3>
  <p>提案されているモデルは「時間制限付き証明決済」です。</p>
  <ol>
      <li>トランザクションデータはまずL1に公開されます（データ可用性）。</li>
      <li>そのL1への影響の最終的な決済は、定義された時間枠（T）内でのZK証明の提出と検証に依存します。</li>
      <li>操作に関与する当事者がこの時間枠内に証明を提供できなかった場合、操作は失敗し、説明責任を確保するためのペナルティが課せられます。</li>
  </ol>
  <p>このモデルは、各ロールアップが自身の「ライブネス」を維持するために証明を提出することに直接的な関心があるため、L1での最終決済よりずっと前に、ユーザー側で高速な楽観的確認を可能にします。</p>
  
  <h3 class="section-title">KIP-15と承認済みトランザクションアーカイブノード（ATAN）</h3>
  <p>Kaspa上のL2にとって根本的な問題はプルーニングです。L2は、L1からプルーニングされたトランザクションデータをどのように参照できるのでしょうか？ZK証明は長期的な解決策ですが、暫定的な解決策が必要です。</p>
  <p>これがKIP-15の目的です。**承認済みトランザクションアーカイブノード（ATAN）**を導入することです。ATANは、プルーニングされたフルノードと完全なアーカイブノードの間に位置します。</p>
  <ul>
      <li>完全なトランザクションデータは保存しません。</li>
      <li>選択されたチェーンのヘッダーと、すべてのトランザクションの**ハッシュ**を保存します。</li>
  </ul>
  <p>トランザクションハッシュはわずか32バイトであり、トランザクション自体と比較して大幅な圧縮となります。ATANは、妥当なストレージ要件（フル容量で年間約3〜5 TBと推定）で、何年ものトランザクションハッシュ履歴を保存できます。これにより、L2は完全なアーカイブノードを必要とせずに過去のトランザクションの存在と順序を証明でき、プルーニングされた環境でのデータ可用性の問題を解決します。</p>
  
  <h3 class="section-title">正規のL1<>L2ブリッジ設計</h3>
  <p>L1とL2の間で資金（KAS）が流れるようにするためには、「正規のブリッジ」が必要です。</p>
  <ul>
      <li><strong>インバウンド（L1からL2へ）：</strong> ユーザーはL1上の静的な委任アドレスにKASを送信します。この操作はL1によって即座に検証され、資金はL2上でほぼ瞬時に使用可能になります。</li>
      <li><strong>アウトバウンド（L2からL1へ）：</strong> アウトバウンドトランザクションはL2での内部承認を必要とします。その有効性は、ZK証明を提出することによってL1で確認されなければなりません。</li>
  </ul>
  <p>これを行うために、Kaspaは「委任」スクリプトを使用します。ユーザーは、ロールアップの状態アドレス（動的）に資金を送る代わりに、ロールアップが提供するZK証明にその支出権限を委任する静的なアドレスに送ります。これにより、ユーザーエクスペリエンスとブリッジの資金管理が簡素化されます。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="chapter15">第15章：Igraネットワーク：KaspaのEVM互換ZKロールアップのケーススタディ</h2>
  <h3 class="section-title">Igraの概要</h3>
  <p>Igraネットワークは、Kaspaのレイヤー2ビジョンの優れた実践例です。これは、KaspaのBlockDAGを分散型シーケンサーおよび決済レイヤーとして独自に使用する**EVM互換ZKロールアップ**です。</p>
  <p>このアーキテクチャは、ビットコインのようなセキュリティと、現代のプログラマブルチェーンの速度と多様性を組み合わせることを目指しており、現在のレイヤー2ソリューションの重大な限界を解決します。</p>
  
  <h3 class="section-title">主要コンポーネント</h3>
  <ul>
      <li><strong>ベースレイヤー（Kaspa）：</strong> 分散型シーケンサーとして機能します。Igraのトランザクション順序は、そのマイニングノードによってKaspaのBlockDAG上で固定されます。</li>
      <li><strong>Igraノード：</strong> L2の完全な状態を維持し、EVMトランザクションを実行します。L1からシーケンスされたトランザクションを抽出し、実行します。</li>
      <li><strong>Igraリレー/ RPC：</strong> ユーザーとネットワーク間のブリッジを提供します。標準的なEthereum RPCインターフェースを公開し、ユーザーがMetaMaskのようなウォレットを使用してIgraと対話できるようにします。</li>
  </ul>
  
  <h3 class="section-title">ブリッジングメカニズムと展開</h3>
  <p>Igraは、KASのラップバージョンであるネイティブトークン$iKASに対して、多段階のブリッジングアプローチを使用します。</p>
  <ol>
      <li><strong>フェーズ1（コミュニティブリッジ）：</strong> 当初、ブリッジングはコミュニティによって選ばれた署名者によって制御されるマルチシグ（m-of-n）ウォレットに依存します。これは、多くの暗号通貨のコミュニティ資金に使用されるものと同様の信頼モデルです。資金を引き出すには、署名者がリクエストを処理する必要があり、トラストレスシステムへの移行を保証するためのセーフガードが設けられています。</li>
      <li><strong>フェーズ2（MPC/ZKブリッジ）：</strong> 将来、このブリッジはトラストレスソリューションに置き換えられます。
          <ul>
              <li><strong>MPC（マルチパーティ計算）ブリッジ：</strong> FROSTのような暗号技術を使用して、バリデーターのセットが完全な秘密鍵を誰も保持することなくトランザクションに署名できるようにします。これにより、許可不要のブリッジングが可能になります。</li>
              <li><strong>ZKブリッジ：</strong> 究極のソリューションです。ユーザーは、L2で$iKASをバーンしたことを証明するZK証明をL1に提出できます。L1上のスクリプトがこの証明を検証し、対応する量のKASをアンロックします。</li>
          </ul>
      </li>
  </ol>
  
  <h3 class="section-title">Caravelテストネット</h3>
  <p>Igraの展開は、「Caravel」テストネットから始まる段階的に行われます。このローンチはいくつかのフェーズで行われます。</p>
  <ol>
      <li><strong>有効化：</strong> ネットワークはKaspaのテストネットで有効化されます。</li>
      <li><strong>コミュニティテスター：</strong> ネットワーク活動を徐々に増やすために、ノードソフトウェアが限られたテスターグループに配布されます。</li>
      <li><strong>一般公開：</strong> ソフトウェアが公開され、誰でもノードを実行して参加できるようになります。</li>
  </ol>
  <p>この慎重な展開プロセスは不可欠です。なぜなら、Caravelは完全なEthereumプロトコルをKaspaのコンセンサスにもたらし、それはEVMの世界ではまだ未踏の速度で動作するからです。安定性とパフォーマンスを確保するためには、集中的なテストと数回のイテレーションが必要です。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="chapter16">第16章：KaspaのBlockDAGにおけるトランザクションスループットと衝突</h2>
  <h3 class="section-title">トランザクション衝突の課題</h3>
  <p>DAGを信じられないほど高速にするのは、並列化する能力です。並列で作成されたブロックはすべて有効と見なされるため、並列ブロックのレートを上げてもセキュリティを損なうことはありません。しかし、疑問が生じます。1秒あたり10ブロックを作成する場合、トランザクションスループットは本当に10倍高くなるのでしょうか？</p>
  <p>完全にはそうではありません。ニュアンスは、並列ブロックが同じトランザクションを含む可能性があり、同じトランザクションを複数回カウントするのは公平ではないということです。私たちは**実効TPS**、つまり平均して含まれるユニークなトランザクションの数に関心を持つべきです。</p>
  
  <h3 class="section-title">ランダム選択分析</h3>
  <p>マイナーが含めるトランザクションをランダムに選択すると仮定すると（これは、後で見るように、合理的な近似です）、実効TPSを分析できます。</p>
  <p>数学的分析によれば、最悪の場合（ブロック容量がメムプール内の利用可能なトランザクション数と完全に一致する場合）でも、ネットワークは少なくとも**(1 - 1/e) ≈ 62.3%**のユニークなトランザクションを含みます。これは下限であり、実際には、メムプールがブロック容量よりも大きい場合、効率は100%に近づく傾向があります。</p>
  <p>その結果、実効TPSはブロックレートとほぼ線形に増加します。ブロックレートが10倍に増加すると、実効TPSは8〜9倍に増加し、これは大幅な改善です。</p>
  
  <h3 class="section-title">不正なマイナーについてはどうですか？</h3>
  <p>「欲張りな」マイナーが、利益を最大化するためにトランザクションの選択を操作しようとするのではないかと心配するかもしれません。例えば、全員が同じ高手数料のトランザクションを選択することで、衝突を増やし、実効TPSを低下させる可能性があります。</p>
  <p>ゲーム理論は、これが最適な戦略ではないことを示しています。ランダム選択は「弱い均衡」です。これは、単一のマイナーがこの戦略から逸脱した場合、わずかな利点を得ることができることを意味します。しかし、多くのマイナーが逸脱し、全員が同じ高手数料のトランザクションを選択した場合、彼らは同じ手数料を直接競合することになり、期待利益は減少します。最終的に、マイナーにとって最も合理的な戦略（他人が何をするか予測できない）は、選択を多様化することであり、これはランダム選択に近似します。</p>
  
  <h3 class="section-title">高い衝突率に対する潜在的な解決策</h3>
  <p>もし、実際には高い衝突率が観測された場合、いくつかの解決策を実装できます。</p>
  <ol>
      <li><strong>トランザクションのバケット化：</strong> ブロックは、ハッシュがブロック自身のハッシュの特定の桁と一致するトランザクションのみを含めるように要求される可能性があります。これにより、トランザクションが「バケット」に分割され、ブロックは同じバケット内のトランザクションのみを競合することになります。</li>
      <li><strong>独占的オークションメカニズム：</strong> マイナーが好きなトランザクションを含めることができるメカニズムですが、ブロック内のすべてのトランザクションの手数料は、含まれるトランザクションの中で最も低い手数料のレベルに設定されます。これにより、マイナーは最も多く支払うトランザクションだけに集中するのではなく、より多くのトランザクションを含める（ボリュームを増やす）インセンティブが生まれ、自然に多様化が促進されます。</li>
  </ol>
  <p>結論として、トランザクションの衝突はBlockDAGにおいて考慮事項ですが、Kaspaのアーキテクチャとゲーム理論のダイナミクスにより、実効スループットは高く維持され、ブロックレートとともに堅牢にスケーリングすることが保証されます。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="chapter17">第17章：Kaspaの手数料市場：ゲーム理論的視点</h2>
  <h3 class="section-title">手数料市場の重要性</h3>
  <p>暗号通貨の手数料市場は、その長期的なセキュリティにとって非常に重要です。ブロック報酬が無視できるほど小さくなると、トランザクション手数料がネットワークセキュリティの主要な補助金として残ります。したがって、プロトコルが誘発する手数料市場のダイナミクスを理解することが重要です。</p>
  
  <h3 class="section-title">ビットコインの手数料市場の三つの悪</h3>
  <p>ビットコインの手数料市場は、「ラウンドごとに単一のリーダー」というコンセンサスのために、「三つの悪」と表現できる特性を示します。</p>
  <ol>
      <li><strong>底辺への競争：</strong> ネットワークが混雑していないとき、需要はブロック空間の供給よりも低くなります。ユーザーは高い手数料を支払うインセンティブがありません。なぜなら、彼らのトランザクションはいずれにせよ含まれるからです。手数料は最小限に近づく傾向があり、これはマイニングを不採算にし、ネットワークセキュリティを脅かす可能性があります。</li>
      <li><strong>価格の異常：</strong> ネットワークが混雑しているとき、手数料が非常にわずかに増加するだけで、トランザクションが「決して含まれない」から「次のブロックに含まれる」に変わることがあります。価格は段階的なサービスを反映していません。</li>
      <li><strong>飢餓状態：</strong> 混雑したネットワークでは、低手数料のトランザクションは、高手数料のトランザクションに決して勝てないため、永久に除外される可能性があります。これは参入障壁を生み出し、ブロックチェーンの平等主義的な精神に疑問を投げかけます。</li>
  </ol>
  <p>これらのダイナミクスは、各ラウンドで単一のマイナーがすべてのポットを獲得するという直接的な結果です。</p>
  
  <h3 class="section-title">KaspaのマルチリーダーBlockDAGが手数料市場をどのように改善するか</h3>
  <p>Kaspaでは、複数のマイナーが各ラウンドで並行してブロックを作成します（マルチリーダー）。複数のマイナーが同じトランザクションを含めた場合、彼らは確率的に報酬を共有します。これにより、マイナーとユーザーのゲームダイナミクスが根本的に変わります。</p>
  <ul>
      <li><strong>底辺への競争に対して：</strong> マイナーは競争状態にあるため、ネットワークが部分的にしか利用されていなくても、収益源を多様化し、直接的な競争を避けるためにトランザクションを含めることが合理的になります。分析によると、手数料市場は、ビットコインの100%に対して、ネットワークがその容量の**1/k**に達するとすぐに活性化します（kはラウンドあたりのリーダー数）。ラウンドあたり10人のリーダーがいる場合、市場は容量の10%が使用されるとすぐに活性化します。</li>
      <li><strong>飢餓状態と異常に対して：</strong> マイナーは、低手数料のものを含む、さまざまなトランザクションを含めるインセンティブがあります。最も高額なトランザクションを争うことは、それらの手数料を獲得する確率が競争によって減少するため、必ずしも最適ではありません。これにより、はるかに滑らかなサービス曲線が作成されます。手数料がわずかに増加すると、突然の変化ではなく、包含確率がわずかに増加します。低手数料のトランザクションは、依然として（たとえ小さくても）含まれる可能性があります。これにより、飢餓状態が防止されます。ラウンドでの包含確率が低いことは、無限の待機時間ではなく、妥当な平均待機時間に変換されます。</li>
  </ul>
  <p>結論として、Kaspaのマルチリーダーアーキテクチャは、高頻度のBlockDAGの直接的な結果であり、本質的に、より健全で、より安定し、より公平な手数料市場を生み出します。単一リーダーのブロックチェーンの極端な「オールオアナッシング」のダイナミクスを滑らかにすることで、Kaspaは長期的なセキュリティのためのより堅牢な経済的基盤を構築します。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="conclusion">結論</h2>
  <div class="conclusion">
    <p>Kaspaのアーキテクチャと哲学を巡るこの旅の終わりに、一つの結論が浮かび上がります。私たちは、分散型台帳技術の分野における真の進化を目の当たりにしているということです。Kaspaは単なる別の暗号通貨ではありません。それは、高速デジタル時代のために設計された、ビットコインによって確立された原則の根本的な再設計です。</p>
    <p>私たちは、GHOSTDAGコンセンサスプロトコルによって統治されるそのBlockDAGが、線形チェーンのボトルネックをどのように解体するかを見てきました。ブロックの並列作成と統合を可能にすることで、Kaspaは孤立ブロックの無駄を排除し、プルーフ・オブ・ワークのエネルギー効率を最大化し、分散型PoWシステムでは不可能と考えられていたトランザクションと確認の速度を達成します。</p>
    <p>私たちは、ノードのハードウェア要件を低く維持することで長期的な分散化を保証する多段階プルーニングシステムによる、ストレージへの独創的な解決策を探求しました。また、ベースレイヤーのセキュリティを犠牲にすることなく、複雑なプログラマビリティと相互運用性をもたらすことを約束するZK-Rollupsのようなレイヤー2ソリューションによる、未来へのビジョンも掘り下げました。</p>
    <p>Kaspaは、ブロックチェーンのトリレンマ、つまりセキュリティ、スケーラビリティ、分散化のいずれかを選択しなければならないという考えが、不変の法則ではなく、第一世代アーキテクチャの限界である可能性があることを示しています。物理学と経済学の原則からインスピレーションを得ることで、Kaspaは最大の効率、最小の摩擦、最適な価値保持を目指すシステムを設計しました。</p>
    <p>Kaspaの未来は有望です。ファイナリティを形式化するDAGKnightのようなアップグレードや、MEV耐性やオラクルに関する継続的な研究により、このプロジェクトは可能なことの限界を押し広げ続けています。Kaspaが次世代の分散型アプリケーションのバックボーンになるか、他のシステムと共存するかは別として、一つ確かなことがあります。それは、貨幣システムが金のように堅固でありながら、光のように高速であり得ることを証明することで、暗号通貨の歴史に消えない足跡をすでに残しているということです。</p>
    <p>本書が、Kaspaの深さと優雅さを理解するための鍵を提供できたことを願っています。旅は始まったばかりであり、それを続ける最善の方法は、関与し、質問し、学び続けることです。</p>
  </div>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="appendixA">付録A：追加リソース</h2>
  <p>Kaspaの理解を深めたい方のために、入門記事から基礎的な研究論文まで、重要なリソースのリストを以下に示します。</p>
  
  <h4>入門記事</h4>
  <ul>
    <li><strong>Kaspa 101</strong>: GHOSTDAGの仕組みを理解するための優れた出発点です。 <a href="https://michaelsutton.github.io/2022-04-23-kaspa-101-part1/">こちらで読む</a></li>
    <li><strong>BlockDAGでビットコインをスケーリングする</strong>: BlockDAGがビットコインの限界に対する実行可能な解決策である理由を説明しています。 <a href="https://someone235.medium.com/scaling-bitcoin-with-blockdag-d785174a3402">こちらで読む</a></li>
    <li><strong>Kaspaプルーニング入門</strong>: Kaspaのプルーニングメカニズムの紹介です。 <a href="https://hashdag.medium.com/in-which-mayday-mayday-we-are-syncing-about-bf05ad58957a">こちらで読む</a></li>
    <li><strong>Kaspa GhostDAG 101 (ビデオ)</strong>: 技術的な概念の包括的なビデオ概要です。 <a href="https://www.youtube.com/watch?v=nhI2zo44dfc">こちらで視聴</a></li>
  </ul>

  <h4>研究論文（詳細）</h4>
  <ul>
    <li><strong>PHANTOMとGHOSTDAG</strong>: Kaspaのコンセンサスの基礎を築いた学術論文です。 <a href="https://eprint.iacr.org/2018/104.pdf">PDFを読む</a></li>
    <li><strong>DAGKnightプロトコル</strong>: 高速なファイナリティと攻撃耐性のために設計された、Kaspaの次世代コンセンサスプロトコルです。 <a href="https://eprint.iacr.org/2022/1494.pdf">PDFを読む</a></li>
    <li><strong>Prunality</strong>: Kaspaのプルーニングメカニズムの背後にある理論を詳述した論文です。 <a href="https://github.com/kaspanet/docs/blob/main/Reference/prunality/Prunality.pdf">PDFを読む</a></li>
    <li><strong>ビットコインホワイトペーパー</strong>: 歴史的背景として、サトシ・ナカモトのオリジナル論文です。 <a href="https://bitcoin.org/bitcoin/bitcoin.pdf">PDFを読む</a></li>
  </ul>

  <h4>コードと開発</h4>
  <ul>
    <li><strong>Rusty-Kaspa (メインリポジトリ)</strong>: Rustで書かれたKaspaノードのソースコードです。 <a href="https://github.com/kaspanet/rusty-kaspa">GitHubで見る</a></li>
    <li><strong>Kaspa改善提案 (KIPs)</strong>: すべてのKaspa改善提案を含むリポジトリです。 <a href="https://github.com/kaspanet/kips">GitHubで見る</a></li>
  </ul>

  <h4>コミュニティとディスカッション</h4>
  <ul>
    <li><strong>Discord</strong>: 技術的およびコミュニティの議論の主要な場所です。推奨チャンネル: <code>#research-general</code>, <code>#development</code>。 <a href="https://discord.gg/kaspa">Discordに参加</a></li>
    <li><strong>Telegram (R&D)</strong>: 開発者と研究者が協力するグループです。 <a href="https://t.me/kasparnd">Telegramで参加</a></li>
    <li><strong>リサーチフォーラム</strong>: KIPや新しい技術コンセプトに関する詳細な議論のためのフォーラムです。 <a href="https://research.kas.pa/">フォーラムを訪問</a></li>
  </ul>

  <hr class="chapter-break">
  
  <h2 class="chapter-title" id="appendixB">付録B：トランザクション衝突の数学的分析（簡略化）</h2>
  <p>この章では、BlockDAGにおける実効TPS（1秒あたりのトランザクション数）の問題を探ります。複数のブロックが並行して作成されると、同じトランザクションが含まれる可能性があり、ユニークなスループットが低下します。分析によると、マイナーによるランダムなトランザクション選択であっても、実効スループットは高いままであることが示されています。</p>
  <p>重要な考え方は、2人のマイナーが同じトランザクションを選択する確率は、保留中のトランザクションプール（メムプール）が増加するにつれて減少するということです。数学的分析（確率論とテイラー級数を使用）によると、ブロック容量が利用可能なトランザクション数と完全に一致するシナリオであっても、ネットワークは少なくとも<strong>(1 - 1/e) ≈ 62.3%</strong>のユニークなトランザクションを含みます。この数値は最小値であり、実際には効率ははるかに高いことが多いです。</p>
  <p>さらに、ゲーム理論は、マイナーがこの準ランダムな選択から逸脱する大きなインセンティブがないことを示唆しています。すべてのマイナーが最も高額なトランザクションを選択しようとすると、同じ手数料を競合することになり、期待利益が減少します。したがって、多様化戦略（ランダム選択）は安定した均衡（「弱い均衡」）です。</p>
  <p>要するに、Kaspaの並列性は実効スループットを大幅に損なうことはなく、ブロックレートとほぼ線形に増加します。</p>

  <hr class="chapter-break">

  <h2 class="chapter-title" id="appendixC">付録C：手数料市場の数学的分析（簡略化）</h2>
  <p>この章では、ゲーム理論を用いて手数料市場のダイナミクスを分析し、ビットコインの「単一リーダー」モデルとKaspaの「マルチリーダー」モデルを比較します。</p>
  <h4>ビットコインの手数料市場の三つの悪：</h4>
  <ol>
    <li><strong>底辺への競争</strong>: ネットワークが混雑していないとき、ユーザーは高い手数料を支払うインセンティブがありません。なぜなら、彼らのトランザクションはいずれにせよ含まれるからです。手数料は最小限に近づく傾向があり、これはネットワークの長期的なセキュリティを脅かします。</li>
    <li><strong>価格の異常</strong>: ネットワークが混雑しているとき、手数料が非常にわずかに増加するだけで、トランザクションが「決して含まれない」から「次のブロックに含まれる」に変わることがあります。価格は段階的なサービスを反映していません。</li>
    <li><strong>飢餓状態</strong>: 混雑したネットワークでは、低手数料のトランザクションは永久に除外される可能性があり、恵まれないユーザーにとって参入障壁となります。</li>
  </ol>
  <h4>KaspaのBlockDAGがこれらの問題をどのように解決するか：</h4>
  <p>Kaspaでは、複数のマイナーが並行してブロックを作成します（マルチリーダー）。複数のマイナーが同じトランザクションを含めた場合、彼らは（確率的に）報酬を共有します。これにより、ダイナミクスが根本的に変わります。</p>
  <ul>
    <li><strong>底辺への競争に対して</strong>: マイナーは競争状態にあるため、ネットワークが部分的にしか利用されていなくてもトランザクションを含めることが合理的になります。分析によると、手数料市場は、ビットコインの100%に対して、ネットワークがその容量の<strong>1/k</strong>に達するとすぐに活性化します（kはラウンドあたりのリーダー数）。ラウンドあたり10人のリーダーがいる場合、市場は容量の10%が使用されるとすぐに活性化します。</li>
    <li><strong>飢餓状態と異常に対して</strong>: マイナーは、低手数料のものを含む、さまざまなトランザクションを含めるインセンティブがあります。最も高額なトランザクションを争うことは、それらの手数料を獲得する確率が競争によって減少するため、必ずしも最適ではありません。これにより、より滑らかなサービス曲線が作成されます。手数料がわずかに増加すると、突然の変化ではなく、包含確率がわずかに増加します。低手数料のトランザクションは、依然として含まれる可能性があります。これにより、飢餓状態が防止されます。</li>
  </ul>
  <p>結論として、Kaspaのマルチリーダーアーキテクチャは、プロトコルの長期的なセキュリティと実行可能性にとって不可欠な、より健全で、より安定し、より公平な手数料市場を生み出します。</p>

</div>
</body>
</html>